import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * 创建当前时间步的单元格状态
 */
export function CreateCurrentTimeStepCell(
  before, timeStep, available, candidates = null, strategies = null,
  relativePos = null, explore = 0) {
  return {
    before: before,
    timeStep: timeStep,
    available: available,
    strategies: strategies === null ? [] : [...strategies],
    candidates: candidates === null ? [] : [...candidates],
    relativePos: relativePos === null ? [] : [...relativePos],
    explore: explore,
  };
}

/**
 * 创建单元格链表结构
 * 用于策略网格中存储单元格的状态和历史信息
 * @param {Object} pos - 位置对象 {x, y}
 * @param {Array} grid - 数独网格
 */
export function CreateCellLinkedList(pos, grid) {
  // 计算候选值
  this.currentPos = {...pos};
  this.isConstant = grid[this.currentPos.y][this.currentPos.x] !== 0;
  this.candidates = [];
  this.strategies = [];
  this.current = null;
  this.relativePos = [];
  this.explore = 0;

  /**
   * 返回网格的可用性
   */
  this.isCellConstant = function() {
    return this.isConstant || this.explore !== 0;
  };

  this.isUserCell = function() {
    return !this.isConstant;
  };

  /**
   * 获取初始候选数
   */
  this.getInitialCandidate = function(row, col) {
    let candidates = Array.from({length: SUDOKU_SIZE}, (_, i) => i + 1);
    const sameRow = grid[row];
    const sameCol = grid.map(row => row[col]);

    // 同一宫
    const boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
    const boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
    const sameBox = [];
    for (let r = boxStartRow; r < boxStartRow + BOX_SIZE; r++) {
      for (let c = boxStartCol; c < boxStartCol + BOX_SIZE; c++) {
        sameBox.push(grid[r][c]);
      }
    }

    const excludeValue = new Set([...sameRow, ...sameCol, ...sameBox]);
    candidates = candidates.filter(candidate => !excludeValue.has(candidate));
    return candidates;
  };

  if (!this.isConstant) {
    this.candidates = this.getInitialCandidate(this.currentPos.y, this.currentPos.x);
    this.current = CreateCurrentTimeStepCell(null, 0, true, this.candidates);
  }

  /**
   * 获取当前单元格的值
   */
  this.getCurrentCell = function() {
    if (this.isConstant) return grid[this.currentPos.y][this.currentPos.x];

    if (this.explore !== 0) return this.explore;

    return this.current;
  };

  /**
   * 返回当前时间步的策略
   */
  this.getStrategies = function() {
    return this.strategies;
  };

  /**
   * 重置策略
   */
  this.resetStrategies = function() {
    this.strategies = [];
  };

  /**
   * 返回当前时间步的相对位置
   */
  this.getRelativePos = function() {
    return this.relativePos;
  };

  /**
   * 重置相对位置
   */
  this.resetRelativePos = function() {
    this.relativePos = [];
  };

  /**
   * 验证输入的数字是否有效
   * @param {Number} num - 要验证的数字
   */
  this.validate = function(num) {
    return this.candidates.some(candidate => candidate === num);
  };

  /**
   * 当策略生效或做出决定时添加新状态
   * @param {Number} newTimeStep - 新的时间步
   */
  this.add = function(newTimeStep) {
    this.timeStep = newTimeStep;
    this.current = CreateCurrentTimeStepCell(
      this.current, 
      this.timeStep,
      this.candidates.length !== 1, 
      this.candidates, 
      this.strategies,
      this.relativePos, 
      this.explore
    );
  };

  /**
   * 返回到分支点
   * @param {Number} specificTimeStep - 特定的时间步
   */
  this.branchBack = function(specificTimeStep) {
    if (specificTimeStep < 0) {
      throw new Error('time step must bigger than zero');
    }

    if (this.isConstant) {
      return;
    }

    while (this.current.timeStep > specificTimeStep) {
      if (this.current.before === null) {
        throw new Error(`time step ${specificTimeStep} less than the value`);
      }
      this.current = this.current.before;
    }

    // 判断此时间步是否使用了策略
    this.strategies = this.current.timeStep === specificTimeStep ? [...this.current.strategies] : [];
    this.relativePos = this.current.timeStep === specificTimeStep ? [...this.current.relativePos] : [];
    this.explore = this.current.explore;
  };
}

