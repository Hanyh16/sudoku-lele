import { get } from 'svelte/store';
import { strategyGrid } from '@sudoku/stores/grid';
import { userGrid } from '@sudoku/stores/grid';
import { strategyManager } from '@sudoku/strategy/strategyManager';
import { CreateCurrentTimeStepCell } from '../cell';
import { historyState } from './state';

class HistoryNode {
  constructor(state, timestamp) {
    this.state = state; // 当前状态
    // this.action = action; // 导致该状态的动作
    // 父/子关系不再保存为独立数组，改为通过 incomingEdges/outgoingEdges 表示
    // this.undoTargets = []; // 撤销路径
    // this.redoTargets = []; // 重做路径
    this.traceFrom = null; // 该节点的来源节点（用于回溯时选择路径）
    this.createdAt = timestamp; // 节点创建时间戳 int
    this.lastAccessedAt = timestamp; // 节点最后访问时间戳 int
    // 边集合（当 command 表示为边时使用）
    this.incomingEdges = [];
    this.outgoingEdges = [];
    this.traceEdges = null;
    
  }


  // 当命令作为边时，记录入/出边
  addIncomingEdge(edge) {
    this.incomingEdges.push(edge);
  }

  addOutgoingEdge(edge) {
    this.outgoingEdges.push(edge);
  }

  

  updateLastAccessed(timestamp) {
    this.lastAccessedAt = timestamp;
  }
}

class HistoryDGA {
  constructor(strategyGrid, userGrid) {
    const initialState = getCurrentBoardState(strategyGrid, userGrid); // 获取初始状态
    this.root = new HistoryNode(initialState, 0); // 使用初始状态作为根节点
    this.current = this.root; // 当前节点
  }

  // 边对象：从一个节点到另一个节点的命令/动作
  _createEdge(fromNode, toNode, action, timestamp) {
    // 如果已经存在相同的 from -> to 边且 action 相同（或未提供 action），复用已有边
    try {
      if (fromNode && fromNode.outgoingEdges && fromNode.outgoingEdges.length > 0) {
          const existing = fromNode.outgoingEdges.find(e => e.to === toNode && (typeof action === 'undefined' || e.action === action));
          if (existing) {
            try { console.debug('[HistoryDGA._createEdge] reusing existing edge', { fromId: fromNode && fromNode.createdAt, toId: toNode && toNode.createdAt, action: action && action.constructor && action.constructor.name }); } catch (e) {}
            return existing;
          }
        }
    } catch (err) {
      // 忽略检测错误，继续创建新边
    }

    // 防止创建自环（from === to），自环会导致回溯逻辑错误
    if (fromNode === toNode) {
      try { console.debug('[HistoryDGA._createEdge] skipping self-edge', { nodeCreatedAt: fromNode && fromNode.createdAt }); } catch (e) {}
      // 如果已有同源边则复用，否则不创建自环
      return null;
    }

    const edge = { from: fromNode, to: toNode, action, createdAt: timestamp };
    fromNode.addOutgoingEdge(edge);
    toNode.addIncomingEdge(edge);
    return edge;
  }

  // 辅助：返回节点的最近访问的父节点（或 null）
  _getLatestParent(node) {
    if (!node || !node.incomingEdges || node.incomingEdges.length === 0) return null;
    // 忽略自环来源（父节点不能是自己）
    const parents = node.incomingEdges.map(e => e.from).filter(p => p && p !== node);
    return parents.reduce((latest, parent) => {
      if (!latest) return parent;
      return parent.lastAccessedAt > latest.lastAccessedAt ? parent : latest;
    }, null);
  }

  // 辅助：返回节点的最近访问的子节点（或 null）
  _getLatestChild(node) {
    if (!node || !node.outgoingEdges || node.outgoingEdges.length === 0) return null;
    // 忽略自环目标
    const children = node.outgoingEdges.map(e => e.to).filter(c => c && c !== node);
    return children.reduce((latest, child) => {
      if (!latest) return child;
      return child.lastAccessedAt > latest.lastAccessedAt ? child : latest;
    }, null);
  }

  // 是否可以回溯（存在父分支可回溯）
  canBacktrack() {
    try {
      // 沿着“最近访问父节点”链向上查找，是否存在一个祖先节点有多个子节点（表示有分支）
      let node = this.current;
      while (node && node.incomingEdges && node.incomingEdges.length > 0) {
        const parent = this._getLatestParent(node);
        if (!parent) break;
        if (parent.outgoingEdges && parent.outgoingEdges.length > 1) {
          // 返回父节点到当前节点的边（如果存在），否则返回父节点的所有出边中的第一个
          const edge = parent.outgoingEdges.find(e => e.to === node);
          try { console.debug('[HistoryDGA.canBacktrack] found branch', { parentCreatedAt: parent.createdAt, parentOutgoing: parent.outgoingEdges.length, edgeExists: !!edge }); } catch (e) {}
          return edge || parent.outgoingEdges[0] || null;
        }
        node = parent;
      }
      return null;
    } catch (err) {
      return null;
    }
  }

  // 是否可以执行一次 undo（存在任意父节点）
  canUndo() {
    try {
      if (!this.current || !this.current.incomingEdges || this.current.incomingEdges.length === 0) return null;
      // 返回从最近父节点到当前节点的那条边
      const parent = this._getLatestParent(this.current);
      if (!parent) return null;
      const edge = this.current.incomingEdges.find(e => e.from === parent) || null;
      try { console.debug('[HistoryDGA.canUndo] current', { currentCreatedAt: this.current.createdAt, incomingLen: this.current.incomingEdges.length, parentCreatedAt: parent.createdAt, edgeExists: !!edge }); } catch (e) {}
      return edge;
    } catch (err) {
      return null;
    }
  }

  // 是否可以执行一次 redo（存在 traceFrom 或 最近访问的子节点）
  canRedo() {
    try {
      if (!this.current) return null;
      if (this.current.traceFrom) {
        // 返回当前节点到 traceFrom 的边（优先使用 traceFrom）
        try { console.debug('[HistoryDGA.canRedo] using traceFrom', { currentCreatedAt: this.current.createdAt, traceFrom: this.current.traceFrom && this.current.traceFrom.createdAt }); } catch (e) {}
        return this.current.traceEdges;
      }
      const child = this._getLatestChild(this.current);
      if (!child) return null;
      const edge = this.current.outgoingEdges.find(e => e.to === child) || null;
      try { console.debug('[HistoryDGA.canRedo] computed', { currentCreatedAt: this.current.createdAt, outgoingLen: this.current.outgoingEdges.length, childCreatedAt: child && child.createdAt, edgeExists: !!edge }); } catch (e) {}
      return edge;
    } catch (err) {
      return null;
    }
  }

  addNode(state, timestamp, action = null, isTrace = false) {
    // 先尝试查找是否已有相同状态的节点，若存在则复用
    let existingNode = this.findNodeByState(state);

    // If the found node is exactly the current node, treat it as not-existing
    // (force creating a new node). This avoids self-edge/identity reuse when
    // the user intentionally creates a 'new' step from the same-looking state
    // (e.g. undo then re-apply). Without this, addNode may try to create a
    // self-edge which we skip and therefore no branch is created.
    if (existingNode && existingNode === this.current) {
      try { console.debug('[HistoryDGA.addNode] existing node is current; forcing new node creation', { createdAt: existingNode.createdAt }); } catch (e) {}
      existingNode = null;
    }

    if (existingNode) {
      try { console.debug('[HistoryDGA.addNode] found existing node', { action: action && action.constructor && action.constructor.name, isTrace, existingCreatedAt: existingNode.createdAt }); } catch (e) {}
      // 若是 trace，确保 trace 信息被记录
      if (isTrace && !existingNode.traceFrom) {
        const edge = { from: this.current, to: existingNode, action, createdAt: timestamp };
        existingNode.traceEdges = edge;
        existingNode.traceFrom = this.current;
      }

      // 创建或复用 from->existing 边，并在实际新增出边时（真正新增分支）增加回溯计数
      try {
        // 使用不同子节点数量来判断是否实际新增了新的子路径，忽略自环或重复边造成的计数干扰
        const prevUnique = this.current && this.current.outgoingEdges ? new Set(this.current.outgoingEdges.map(e => e.to)).size : 0;
        const edge = this._createEdge(this.current, existingNode, action, timestamp);
        const postUnique = this.current && this.current.outgoingEdges ? new Set(this.current.outgoingEdges.map(e => e.to)).size : 0;
        try { console.debug('[HistoryDGA.addNode] edge create', { prevUnique, postUnique, action: action && action.constructor && action.constructor.name, edgeCreated: !!edge }); } catch (e) {}
        // 额外打印当前节点与目标节点的简要 userGrid 摘要，便于比较状态相等性
        try {
          const summarize = (s) => (s && s.userGrid ? s.userGrid.flat().join(',') : '');
          console.debug('[HistoryDGA.addNode] state-summaries', { currentSummary: summarize(this.current.state), existingSummary: summarize(existingNode.state) });
        } catch (e) {}
        const isFill = action && action.constructor;
        const preHasOtherChildren = prevUnique > 0;
        if (isFill && preHasOtherChildren && postUnique > prevUnique) {
          historyState.addBranch();
        }
      } catch (err) {
        // 忽略检测错误，尝试确保边被创建
        this._createEdge(this.current, existingNode, action, timestamp);
      }
      this.current = existingNode;
      this.current.updateLastAccessed(timestamp);
      return;
    }

    // 不存在相同节点：创建新节点并连接
    const newNode = new HistoryNode(state, timestamp); // 使用 timestamp 替代 action
    // 通过边把当前节点和新节点连接，并将命令作为边的信息
    if (isTrace) {
      const edge = { from: this.current, to: newNode, action, createdAt: timestamp };
      newNode.traceEdges = edge;
      newNode.traceFrom = this.current;
    }
    else {
      // 创建 from->newNode 边，只有当实际添加了新的出边（基于不同子节点数）时才增加回溯计数
      try {
        const prevUnique = this.current && this.current.outgoingEdges ? new Set(this.current.outgoingEdges.map(e => e.to)).size : 0;
        const edge = this._createEdge(this.current, newNode, action, timestamp);
        const postUnique = this.current && this.current.outgoingEdges ? new Set(this.current.outgoingEdges.map(e => e.to)).size : 0;
        try { console.debug('[HistoryDGA.addNode] created new node edge', { prevUnique, postUnique, action: action && action.constructor && action.constructor.name }); } catch (e) {}
        const isFill = action && action.constructor && action.constructor.name === 'FillCommand';
        const preHasOtherChildren = prevUnique > 0;
        if (isFill && preHasOtherChildren && postUnique > prevUnique) {
          historyState.addBranch();
        }
      } catch (err) {
        // 忽略检测错误，继续创建边
        this._createEdge(this.current, newNode, action, timestamp);
      }
    }
    this.current = newNode; // 更新当前节点
    
  }

  backtrack(action) {
    // 从当前节点沿最近访问父链向上查找第一个有多个子节点的祖先（分支点）
    let node = this.current;
    while (node && node.incomingEdges && node.incomingEdges.length > 0) {
      const parent = this._getLatestParent(node);
      if (!parent) break;
      if (parent.outgoingEdges && parent.outgoingEdges.length > 1) {
        // 设置 traceFrom 为之前的节点，并同时记录 traceEdges，这样
        // canRedo() 能返回一个可识别的边（traceEdges），从而支持 redo
        // 在 backtrack 后恢复到被回溯的分支点时可以执行 redo
        const previous = this.current;
        const timestamp = previous.lastAccessedAt + 1; // 使用逻辑时间戳
        parent.traceFrom = previous;
        parent.traceEdges = { from: parent, to: previous, action: action, createdAt: timestamp };

        // 更新 current 为分支点并记录访问时间
        this.current = parent;
        this.current.updateLastAccessed(timestamp);
        return this.current;
      }
      node = parent; // 继续向上
    }

    throw new Error('No branch node found during backtrack');
  }
  undoStep() {
   
    const previousNode = this._getLatestParent(this.current); // 寻找最近访问的父节点

    if (previousNode) {
      // if (this.current) {
      //   const uniqueChildren = this.current.outgoingEdges ? new Set(this.current.outgoingEdges.map(e => e.to)).size : 0;
      //   // Clear trace metadata (traceEdges and traceFrom). We do not alter
      //   // incoming/outgoingEdges because traceEdges are stored separately.
      //   this.current.traceEdges = null;
      //   this.current.traceFrom = null;
      //   console.log('[HistoryDGA.undoStep] clearing trace metadata for current', { uniqueChildren });
        
      // }
      
      const timestamp = this.current.lastAccessedAt + 1; // 使用逻辑时间戳
      this.current = previousNode; // 更新当前节点为最近访问的父节点
      const uniqueChildren = this.current.outgoingEdges ? new Set(this.current.outgoingEdges.map(e => e.to)).size : 0;
      if (uniqueChildren > 1) {
          // Decrement the UI-visible branch counter (safe no-op if already zero)
          try { historyState.popBranch(); } catch (e) { /* ignore */ }
        }
      this.current.updateLastAccessed(timestamp); // 更新最后访问时间
      return this.current; // 返回当前节点的状态
    }

    return false; // 如果没有父节点，返回 false
  }

  redoStep() {
    let nextNode;

    if (this.current.traceFrom) {
      nextNode = this.current.traceFrom; // 优先使用 traceFrom
    } else {
      nextNode = this._getLatestChild(this.current); // 否则选择最后访问的子节点
    }

    if (nextNode) {
      this.current.traceFrom = null;
      
      this.current = nextNode; // 更新当前节点为目标节点
      this.current.updateLastAccessed(this.current.lastAccessedAt + 1); // 更新最后访问时间
      return this.current; // 返回当前节点的状态
    }

    return false; // 如果没有目标节点，返回 false
  }

  

  findNodeByState(state) {
    // 遍历所有节点，查找是否存在与目标状态相同的节点
    const stack = [this.root]; // 从根节点开始遍历
    console.debug('[HistoryDGA.findNodeByState] root', { thisroot: this.root });
    while (stack.length > 0) {
      const node = stack.pop();

      console.debug('[HistoryDGA.findNodeByState] checking node', { node: node.state, state });
    
      if (JSON.stringify(node.state) === JSON.stringify(state)) {
        return node; // 找到匹配的节点
      } else {
        try {
          const diffs = computeStateDiff(node.state, state, 100);
          if (diffs && diffs.length) {
            console.debug('[HistoryDGA.findNodeByState] node.state !== state; diffs (up to 100):', diffs);
          }
        } catch (e) {
          console.warn('[HistoryDGA.findNodeByState] failed to compute diffs', e);
        }
      }
      node.outgoingEdges.forEach(edge => {
        const child = edge.to;
        if (!stack.includes(child)) stack.push(child);
      });
    }
    return null; // 未找到匹配的节点
  }

  // Export DOT format for debugging/visualization
  toDOT() {
    // collect nodes
    const nodes = new Set();
    const edges = [];
    const stack = [this.root];
    while (stack.length) {
      const node = stack.pop();
      if (!node || nodes.has(node)) continue;
      nodes.add(node);
      // record outgoing edges
      (node.outgoingEdges || []).forEach((e, idx) => {
        if (!e || !e.to) return;
        edges.push({ from: node, to: e.to, action: e.action && e.action.constructor && e.action.constructor.name });
        stack.push(e.to);
      });
    }

    // assign ids
    const idMap = new Map();
    let i = 0;
    nodes.forEach(n => idMap.set(n, `n${++i}`));

    const lines = ['digraph history {', '  rankdir=LR;', '  node [shape=box];'];
    nodes.forEach(n => {
      const id = idMap.get(n);
      const label = `created:${n.createdAt}\nlast:${n.lastAccessedAt}`;
      lines.push(`  ${id} [label="${label}"];`);
    });

    edges.forEach((e, idx) => {
      const from = idMap.get(e.from);
      const to = idMap.get(e.to);
      const label = e.action ? e.action : '';
      lines.push(`  ${from} -> ${to} [label="${label}"];`);
    });

    lines.push('}');
    return lines.join('\n');
  }
}

/**
 * 获取当前策略网格和用户网格的状态
 * @param {Array} strategyGrid - 策略网格
 * @param {Array} userGrid - 用户网格
 * @returns {Object} 包含策略网格和用户网格状态的对象
 */
function getCurrentBoardState(strategyGrid, userGrid) {
  // Produce a serializable snapshot that contains only the primitive/array
  // fields we need to restore live cell objects later. We avoid storing
  // function references or complex closures so snapshots are immutable
  // and won't be mutated later when live cells change.
  const strategySnapshot = strategyGrid.map(row => row.map(cell => {
    const cur = cell.getCurrentCell();
    const current = cur && typeof cur === 'object'
      ? {
          timeStep: cur.timeStep,
          available: cur.available,
          candidates: Array.isArray(cur.candidates) ? [...cur.candidates] : [],
          strategies: Array.isArray(cur.strategies) ? [...cur.strategies] : [],
          relativePos: Array.isArray(cur.relativePos) ? [...cur.relativePos] : [],
          explore: cur.explore || 0,
        }
      : (typeof cur === 'number' ? { explore: cur, timeStep: null } : null);

    // Ensure constants' explore contains their fixed number so initial
    // snapshots reflect constant cell values in the `explore` field.
    const exploreValue = cell.isConstant
      ? (typeof cur === 'number' ? cur : (cell.explore || 0))
      : (cell.explore || 0);

    return {
      currentPos: cell.currentPos ? { ...cell.currentPos } : null,
      isConstant: !!cell.isConstant,
      explore: exploreValue,
      strategies: Array.isArray(cell.strategies) ? [...cell.strategies] : [],
      relativePos: Array.isArray(cell.relativePos) ? [...cell.relativePos] : [],
      candidates: Array.isArray(cell.candidates) ? [...cell.candidates] : [],
      current: current,
    };
  }));

  // userGrid contains plain numeric values; deep copy to avoid sharing references
  const userSnapshot = userGrid.map(row => row.map(cell => cell));

  return {
    strategyGrid: strategySnapshot,
    userGrid: userSnapshot,
    // preserve last applied strategy positions so UI can restore which cells
    // are considered part of the most recent strategy application
    lastAppliedPositions: (typeof strategyManager.getLastAppliedPositions === 'function') ? strategyManager.getLastAppliedPositions() : [],
    // preserve whether a strategy was active
    isUsingStrategy: (() => {
      try {
        const s = strategyManager.getIsUsingStrategy();
        // s is a store-like object with subscribe, so use get() to read it
        return get(s);
      } catch (e) {
        return false;
      }
    })(),
  };
}

/**
 * Apply a serializable snapshot back into the live strategy/user grids.
 * This updates existing cell objects (so their methods/closures stay intact)
 * instead of replacing the whole grid object.
 */
function applyBoardStateToLive(state) {
  if (!state) return;
  const sSnap = state.strategyGrid;
  const uSnap = state.userGrid;

  // Update strategy cells in-place so methods (closures) remain usable
  strategyGrid.getStrategyGrid().update(($grid) => {
    for (let y = 0; y < $grid.length; y++) {
      for (let x = 0; x < $grid[y].length; x++) {
        const cell = $grid[y][x];
        const s = (sSnap && sSnap[y] && sSnap[y][x]) ? sSnap[y][x] : null;
        if (!s) continue;

        // primitives / arrays
        cell.explore = s.explore || 0;
        cell.strategies = Array.isArray(s.strategies) ? [...s.strategies] : [];
        cell.relativePos = Array.isArray(s.relativePos) ? [...s.relativePos] : [];
        cell.candidates = Array.isArray(s.candidates) ? [...s.candidates] : [];

        // Reconstruct the current snapshot for this cell when applicable
        if (!cell.isConstant && s.current && typeof s.current === 'object') {
          // Use CreateCurrentTimeStepCell to produce a consistent current object
          cell.current = CreateCurrentTimeStepCell(
            null,
            s.current.timeStep ?? 0,
            !!s.current.available,
            Array.isArray(s.current.candidates) ? [...s.current.candidates] : [],
            Array.isArray(s.current.strategies) ? [...s.current.strategies] : [],
            Array.isArray(s.current.relativePos) ? [...s.current.relativePos] : [],
            s.current.explore || 0
          );
          // Optionally update timeline mapping for this timeStep
          try {
            if (!cell.timeline) cell.timeline = {};
            if (typeof cell.current.timeStep === 'number') {
              cell.timeline[cell.current.timeStep] = cell.current;
            }
          } catch (e) {}
        } else if (typeof s.current === 'object' && s.current.explore != null) {
          // For constant cells or numeric explore-only, set explore
          cell.explore = s.current.explore || 0;
        }
      }
    }
    return $grid;
  });

  // Replace user grid with numeric snapshot (safe to set whole grid)
  if (uSnap) {
    try { userGrid.setGrid(uSnap); } catch (e) { userGrid.update(() => uSnap); }
  }

  // Restore strategy manager state (lastAppliedPositions / isUsingStrategy) if available
  try {
    if (state && Array.isArray(state.lastAppliedPositions) && typeof strategyManager.setLastAppliedPositions === 'function') {
      strategyManager.setLastAppliedPositions(state.lastAppliedPositions);
    }
    if (state && typeof state.isUsingStrategy !== 'undefined') {
      try { strategyManager.getIsUsingStrategy().set(!!state.isUsingStrategy); } catch (e) {}
    }
  } catch (e) {}

  // Recompute candidates for the UI
  strategyGrid.updateCellCandidates();
}

/**
 * Initialize or reset the history root node from the current live grids.
 * Call this after a new puzzle is generated or a custom puzzle is loaded.
 */
function initHistoryFromLive() {
  try {
    const initialState = getCurrentBoardState(get(strategyGrid.getStrategyGrid()), get(userGrid));
    const timestamp = 0;
    // Reset the root and current pointers
    if (historyDGA && historyDGA.root) {
      historyDGA.root = new HistoryNode(initialState, timestamp);
      historyDGA.current = historyDGA.root;
    }
  } catch (e) {
    try { console.warn('[initHistoryFromLive] failed to init history root', e); } catch (err) {}
  }
}

export { HistoryNode, HistoryDGA, getCurrentBoardState, applyBoardStateToLive, initHistoryFromLive };

// 导出一个全局的 HistoryDGA 单例，供其他模块使用
// Create global HistoryDGA singleton
const historyDGA = new HistoryDGA(get(strategyGrid.getStrategyGrid()), get(userGrid));
export { historyDGA };

// Helper: compute path-level diffs between two state-like objects.
function computeStateDiff(a, b, limit = 100) {
  const diffs = [];
  const seen = new WeakSet();

  function add(path, va, vb) {
    if (diffs.length >= limit) return;
    diffs.push({ path, a: va, b: vb });
  }

  function walk(x, y, path) {
    if (diffs.length >= limit) return;
    // identical
    if (x === y) return;

    const tx = x === null ? 'null' : typeof x;
    const ty = y === null ? 'null' : typeof y;

    // primitives or different primitive types
    if ((tx !== 'object' && tx !== 'function') || (ty !== 'object' && ty !== 'function')) {
      add(path, x, y);
      return;
    }

    // avoid cycles
    try {
      if (x && typeof x === 'object') {
        if (seen.has(x)) return; seen.add(x);
      }
    } catch (e) {}

    // arrays
    if (Array.isArray(x) || Array.isArray(y)) {
      if (!Array.isArray(x) || !Array.isArray(y)) { add(path, x, y); return; }
      if (x.length !== y.length) add(path + '.length', x.length, y.length);
      const n = Math.max(x.length, y.length);
      for (let i = 0; i < n && diffs.length < limit; i++) walk(x[i], y[i], `${path}[${i}]`);
      return;
    }

    // objects
    const keys = new Set();
    try { if (x && typeof x === 'object') Object.keys(x).forEach(k => keys.add(k)); } catch (e) {}
    try { if (y && typeof y === 'object') Object.keys(y).forEach(k => keys.add(k)); } catch (e) {}

    for (const k of keys) {
      if (diffs.length >= limit) break;
      try { walk(x ? x[k] : undefined, y ? y[k] : undefined, path ? `${path}.${k}` : k); } catch (e) { add(path ? `${path}.${k}` : k, x ? x[k] : undefined, y ? y[k] : undefined); }
    }
  }

  try { walk(a, b, ''); } catch (e) { diffs.push({ path: '', a, b, error: String(e) }); }
  return diffs;
}