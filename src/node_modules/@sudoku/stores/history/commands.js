import { get } from 'svelte/store';
import { strategyGrid } from '@sudoku/stores/grid';
import { userGrid } from '@sudoku/stores/grid';
import { strategyManager } from '@sudoku/strategy/strategyManager';
import { cursor } from '@sudoku/stores/cursor';
import { historyState } from './state';

// 将策略网格同步回用户网格（只同步可变格的 explore 值）
function syncUserGridFromStrategyGrid() {
  const $grid = get(strategyGrid.getStrategyGrid());
  $grid.forEach((row) => {
    row.forEach((cell) => {
      if (!cell.isConstant) {
        const cur = cell.getCurrentCell();
        const val = typeof cur === 'number' ? cur : (typeof cell.explore === 'number' && cell.explore > 0 ? cell.explore : 0);
        userGrid.set(cell.currentPos, val || 0);
      }
    });
  });
}

// 命令工厂：提示动作（包含时间步推进/回滚和分支标记）
export function createHintAction({ timeStepBefore, positions, isSingle, values = [] }) {
  const hasBranch = !isSingle;
  return {
    apply: () => {
      const nextTs = timeStepBefore + 1;
      strategyGrid.setTimeStep(nextTs);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        // 不自动将单候选写入 explore，保留为候选让用户选择
        positions.forEach((pos) => {
          $strategyGrid[pos.y][pos.x].add(nextTs);
        });
        // 为所有非题面常量单元格在该时间步补齐快照，确保时间旅行时全局一致
        $strategyGrid.map((row) => row.map((cell) => {
          if (!cell.isConstant && cell.current?.timeStep !== nextTs) {
            cell.add(nextTs);
          }
        }));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      syncUserGridFromStrategyGrid();
      if (hasBranch) {
        const ts = get(strategyGrid.getTimeStep());
        historyState.addBranch(ts);
      }
      strategyManager.getIsUsingStrategy().set(true);
      cursor.reset();
      return true;
    },
    undo: () => {
      strategyGrid.setTimeStep(timeStepBefore);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => {
          cell.gotoTimeStep(timeStepBefore); // 恢复到目标时间步，包括候选数是否可见的状态
        }));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      syncUserGridFromStrategyGrid();
      if (hasBranch && get(historyState.branchBackTimes) > 0) {
        historyState.popBranch();
      }
      cursor.reset();
      return true;
    },
    redo: () => {
      const nextTs = timeStepBefore + 1;
      strategyGrid.setTimeStep(nextTs);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => {
          cell.gotoTimeStep(nextTs);
        }));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      syncUserGridFromStrategyGrid();
      if (hasBranch) {
        const ts = get(strategyGrid.getTimeStep());
        historyState.addBranch(ts);
      }
      cursor.reset();
      return true;
    },
  };
}

// 命令工厂：手动填数/清除（无分支）
export function createFillAction({ timeStepBefore, pos, value }) {
  return {
    apply: () => {
      const nextTs = timeStepBefore + 1;
      strategyGrid.setTimeStep(nextTs);
      // 重置策略标记，再写入当前格
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => {
          cell.resetRelativePos();
          cell.resetStrategies();
        }));
        $strategyGrid[pos.y][pos.x].explore = value;
        $strategyGrid[pos.y][pos.x].strategies = [];
        $strategyGrid[pos.y][pos.x].relativePos = [];
        $strategyGrid[pos.y][pos.x].add(nextTs);
        // 为所有非题面常量单元格在该时间步补齐快照，确保时间旅行时全局一致
        $strategyGrid.map((row) => row.map((cell) => {
          if (!cell.isConstant && cell.current?.timeStep !== nextTs) {
            cell.add(nextTs);
          }
        }));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates([pos]);
      strategyManager.getIsUsingStrategy().set(false);
      cursor.reset();
      syncUserGridFromStrategyGrid();
      
      return true;
    },
    undo: () => {
      strategyGrid.setTimeStep(timeStepBefore);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => {
          cell.gotoTimeStep(timeStepBefore); // 恢复到目标时间步，包括候选数是否可见的状态
        }));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      cursor.reset();
      syncUserGridFromStrategyGrid();
      
      return true;
    },
    redo: () => {
      const nextTs = timeStepBefore + 1;
      strategyGrid.setTimeStep(nextTs);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => {
          cell.gotoTimeStep(nextTs);
        }));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      cursor.reset();
      syncUserGridFromStrategyGrid();
      
      return true;
    },
  };
}

// 命令工厂：回溯（记录回溯前后时间步）
export function createBacktrackAction({ fromTimeStep, toTimeStep }) {
  return {
    apply: () => {
      console.debug('[backtrack] from', fromTimeStep, 'to', toTimeStep);
      strategyGrid.setTimeStep(toTimeStep);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => cell.gotoTimeStep(toTimeStep)));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      // 回溯消耗一个分支标记
      historyState.popBranch();
      strategyManager.getIsUsingStrategy().set(true);
      cursor.reset();
      syncUserGridFromStrategyGrid();
      
      return true;
    },
    undo: () => {
      strategyGrid.setTimeStep(fromTimeStep);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => cell.gotoTimeStep(fromTimeStep)));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      // 撤销回溯时把分支标记补回去
      historyState.addBranch(toTimeStep);
      cursor.reset();
      syncUserGridFromStrategyGrid();
      
      return true;
    },
    redo: () => {
      strategyGrid.setTimeStep(toTimeStep);
      strategyGrid.getStrategyGrid().update(($strategyGrid) => {
        $strategyGrid.map((row) => row.map((cell) => cell.gotoTimeStep(toTimeStep)));
        return $strategyGrid;
      });
      strategyGrid.updateCellCandidates();
      // redo 回溯时消耗一个分支标记
      historyState.popBranch();
      strategyManager.getIsUsingStrategy().set(true);
      cursor.reset();
      syncUserGridFromStrategyGrid();
      
      return true;
    },
  };
}
