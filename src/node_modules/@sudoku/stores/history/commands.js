import { get } from 'svelte/store';
import { strategyGrid } from '@sudoku/stores/grid';
import { userGrid } from '@sudoku/stores/grid';
import { strategyManager } from '@sudoku/strategy/strategyManager';
import { cursor } from '@sudoku/stores/cursor';
import { historyState } from './state';
import { getCurrentBoardState, historyDGA, applyBoardStateToLive } from './board_state';

// 将策略网格同步回用户网格（只同步可变格的 explore 值）
function syncUserGridFromStrategyGrid() {
  const $grid = get(strategyGrid.getStrategyGrid());
  $grid.forEach((row) => {
    row.forEach((cell) => {
      if (!cell.isConstant) {
        const cur = cell.getCurrentCell();
        const val = typeof cur === 'number' ? cur : (typeof cell.explore === 'number' && cell.explore > 0 ? cell.explore : 0);
        userGrid.set(cell.currentPos, val || 0);
      }
    });
  });
}

// 命令工厂：提示动作（包含时间步推进/回滚和分支标记）
class Command {
  constructor(description, state) {
    this.description = description; // 命令描述
    this.state = state; // 操作后的数独状态
    this.preState = null; // 操作前的数独状态
    this.postState = null; // 操作后的数独状态
  }

  captureState() {
    // 捕获当前数独状态（伪代码，需要替换为实际实现）
    return get(strategyGrid.getStrategyGrid());
  }

  apply() {
    throw new Error('apply() 方法需要在子类中实现');
  }

  undo() {
    throw new Error('undo() 方法需要在子类中实现');
  }
}

class HintCommand extends Command {
  constructor(state, description) {
    super(description, state);
  }

  apply() {
    // this.preState = this.captureState(); // 捕获操作前状态
    this.currentState = historyDGA.current
    strategyGrid.updateCellCandidates();
    strategyManager.getIsUsingStrategy().set(true);

    this.postState = getCurrentBoardState(get(strategyGrid.getStrategyGrid()), get(userGrid)); // 捕获操作后状态
  
    const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0; // 使用与 action 时间戳一致的逻辑时间

    

    historyDGA.addNode(this.postState, timestamp, this); // 创建新的 DAG 节点，并将命令作为边
    this.state = historyDGA.current.state; // 更新命令状态为当前节点状态

    return { ...this.state, timeStep: 0 };
  }

  undo() {
    const undoNode = historyDGA.undoStep(); // 回退到上一个 DAG 节点
    if (undoNode) {
      // 使用通用的 applyBoardStateToLive 将快照写回到 live grids（就地更新）
      applyBoardStateToLive(undoNode.state);
      cursor.reset(); // 重置光标

      const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0; // 使用链式时间戳
      undoNode.updateLastAccessed(timestamp); // 更新回退节点的最后访问时间
    }
    return true;
  }

  redo() {
    const redoNode = historyDGA.redoStep(); // 前进到下一个 DAG 节点
    if (redoNode) {
      // // 使用 DAG 节点快照恢复界面状态，确保分支/重做情形一致性
      // console.debug('[FillCommand.redo] restoring from DAG node', redoNode && redoNode.id);
      // 使用通用的 applyBoardStateToLive 将快照写回到 live grids（就地更新）
      applyBoardStateToLive(redoNode.state);
      cursor.reset();

      const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0;
      redoNode.updateLastAccessed(timestamp);
    }
    return true;
  }
}

class FillCommand extends Command {
  constructor(state, step) {
    super(`时间步操作: ${step > 0 ? '推进' : '回滚'} ${Math.abs(step)} 步`, state);
    this.step = step; // 时间步数
  }

  apply() {
    // this.preState = this.captureState(); // 捕获操作前状态
    this.currentState = historyDGA.current
    const { timeStepBefore, pos, value } = this.state;
    const nextTs = timeStepBefore + 1;

    // strategyGrid.setTimeStep(nextTs);
    strategyGrid.getStrategyGrid().update(($strategyGrid) => {
      $strategyGrid.map((row) => row.map((cell) => {
        cell.resetRelativePos();
        cell.resetStrategies();
      }));
      $strategyGrid[pos.y][pos.x].explore = value;
      $strategyGrid[pos.y][pos.x].strategies = [];
      $strategyGrid[pos.y][pos.x].relativePos = [];
      // $strategyGrid[pos.y][pos.x].add(nextTs);
      // $strategyGrid.map((row) => row.map((cell) => {
      //   if (!cell.isConstant && cell.current?.timeStep !== nextTs) {
      //     cell.add(nextTs);
      //   }
      // }));
      return $strategyGrid;
    });

    // 在该时间步清空策略管理器的记录（填数时策略不再使用）
    // strategyManager.snapshotLastApplied(nextTs, []);
    strategyGrid.updateCellCandidates([pos]);
    strategyManager.getIsUsingStrategy().set(false);
    cursor.reset();
    // apply 时需要同步用户网格（保留）
    syncUserGridFromStrategyGrid();

    // 在所有 UI 更新与同步完成后再捕获 postState，确保 DAG 快照反映界面最终状态
    this.postState = getCurrentBoardState(get(strategyGrid.getStrategyGrid()), get(userGrid)); // 捕获操作后状态

    const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0;
    historyDGA.addNode(this.postState, timestamp, this); // 将状态添加到 DAG，并把命令作为边

    return true;
  }

  undo() {
    const undoNode = historyDGA.undoStep(); // 回退到上一个 DAG 节点
    if (undoNode) {
      // 使用通用的 applyBoardStateToLive 将快照写回到 live grids（就地更新）
      applyBoardStateToLive(undoNode.state);
      cursor.reset(); // 重置光标

      const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0; // 使用链式时间戳
      undoNode.updateLastAccessed(timestamp); // 更新回退节点的最后访问时间
    }
    return true;
  }

  redo() {
    const redoNode = historyDGA.redoStep(); // 前进到下一个 DAG 节点
    if (redoNode) {
      // 使用通用的 applyBoardStateToLive 将快照写回到 live grids（就地更新）
      applyBoardStateToLive(redoNode.state);
      cursor.reset(); // 重置光标

      const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0; // 使用链式时间戳
      redoNode.updateLastAccessed(timestamp); // 更新前进节点的最后访问时间
    }
    return true;
  }
}

class BacktrackCommand extends Command {
  constructor(state, branchName) {
    super(`标记分支: ${branchName}`, state);
    this.branchName = branchName; // 分支名称
  }

  apply() {
    // 捕获当前 DGA 引用
    this.currentState = historyDGA.current;
    const { fromTimeStep, toTimeStep } = this.state;
    console.debug('[backtrack] from', fromTimeStep, 'to', toTimeStep);

    // 消耗一个分支计数（用于 UI 徽章/计数展示）
    const popped = historyState.popBranch();
    this._poppedBranch = !!popped;
    try { console.debug('[BacktrackCommand.apply] popped branch?', { popped: this._poppedBranch, branchBackTimes: get(historyState.branchBackTimes) }); } catch (e) {}

    // 使用 HistoryDGA 的 backtrack() 将 history 指针移动到最近的分支点
    let branchNode = null;
    try {
      try { console.debug('[BacktrackCommand.apply] before backtrack currentCreatedAt', historyDGA.current && historyDGA.current.createdAt); } catch (e) {}
      branchNode = historyDGA.backtrack(this);
      try { console.debug('[BacktrackCommand.apply] after backtrack currentCreatedAt', historyDGA.current && historyDGA.current.createdAt); } catch (e) {}
    } catch (err) {
      console.debug('[BacktrackCommand.apply] historyDGA.backtrack failed', err);
      // 如果失败且已弹出分支计数，补回计数
      if (this._poppedBranch) {
        historyState.addBranch();
      }
      return false;
    }

    // 恢复界面到分支节点快照（strategyGrid + userGrid）
    try {
      // 将分支节点快照写回到 live grids（就地更新）
      applyBoardStateToLive(branchNode.state || historyDGA.current.state);
      strategyManager.getIsUsingStrategy().set(true);
      cursor.reset();
    } catch (err) {
      console.debug('[BacktrackCommand.apply] restore UI failed', err);
    }

    // 把命令的 postState 指向新的当前节点状态，便于记录/回放
    // 使用已经保存的分支快照作为 postState（若不存在则从 live grids 生成）
    this.postState = branchNode.state || getCurrentBoardState(get(strategyGrid.getStrategyGrid()), get(userGrid));

    // historyDGA.backtrack 已经移动了 current 节点，故不再创建新的 addNode（避免重复）
    return true;
  }

  undo() {
    const undoNode = historyDGA.undoStep(); // 回退到上一个 DAG 节点
    if (undoNode) {
      // 使用 DAG 节点快照恢复状态并修复未定义变量引用
      console.debug('[BacktrackCommand.undo] restoring from DAG node', undoNode && undoNode.id);
      // 使用通用的 applyBoardStateToLive 将快照写回到 live grids（就地更新）
      applyBoardStateToLive(undoNode.state);

      // // 撤销回溯时把分支标记补回去（从命令的 state 获取 toTimeStep）
      // const { toTimeStep } = this.state;
      // historyState.addBranch(toTimeStep);

      cursor.reset();
      // 已使用 DAG 快照恢复用户网格，跳过从策略网格的二次同步以保留快照
      const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0;
      undoNode.updateLastAccessed(timestamp);
    }
    return true;
  }

  redo() {
    const redoNode = historyDGA.redoStep(); // 前进到下一个 DAG 节点
    if (redoNode) {
      console.debug('[BacktrackCommand.redo] restoring from DAG node', redoNode && redoNode.id);

      // 使用通用的 applyBoardStateToLive 将快照写回到 live grids（就地更新）
      applyBoardStateToLive(redoNode.state);

      // redo 回溯时恢复此前被弹出的分支（将分支计数加回）
      if (this._poppedBranch) {
        historyState.addBranch();
      }
      strategyManager.getIsUsingStrategy().set(true);
      cursor.reset();
      // 已使用 DAG 快照恢复用户网格，跳过从策略网格的二次同步以保留快照
      const timestamp = historyDGA.current ? historyDGA.current.lastAccessedAt + 1 : 0;
      redoNode.updateLastAccessed(timestamp);
    }
    return true;
  }
}

export { Command, HintCommand, FillCommand, BacktrackCommand };

// 命令工厂：提示动作（包含时间步推进/回滚和分支标记）
export function createHintAction({ timeStepBefore, positions, isSingle, values = [] }) {
  const hasBranch = !isSingle;
  const state = { timeStepBefore, positions, isSingle, values, hasBranch };

  return new HintCommand(state, `提示动作: ${positions.length} 个位置`);
}

// 命令工厂：手动填数/清除（无分支）
export function createFillAction({ timeStepBefore, pos, value }) {
  const state = { timeStepBefore, pos, value };
  return new FillCommand(state, `填数: 在 (${pos.x}, ${pos.y}) 填入 ${value}`);
}

// 命令工厂：回溯（记录回溯前后时间步）
export function createBacktrackAction({ fromTimeStep, toTimeStep }) {
  const state = { fromTimeStep, toTimeStep };

  return new BacktrackCommand(state, `回溯: 从 ${fromTimeStep} 到 ${toTimeStep}`);
}
