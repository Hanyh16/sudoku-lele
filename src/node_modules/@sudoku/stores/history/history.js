import { get } from 'svelte/store';
import { historyState } from '@sudoku/stores/history/state';
import { createHintAction, createFillAction, createBacktrackAction } from '@sudoku/stores/history/commands';
import { gotoTimeStep, recomputeCandidates, rollbackAllCellsTo, refreshAfterTimeTravel } from '@sudoku/stores/history/helpers';
import { strategyGrid } from '@sudoku/stores/grid';
import { historyDGA, applyBoardStateToLive } from '@sudoku/stores/history/board_state';
import { userGrid } from '@sudoku/stores/grid';
// import { strategyGrid } from '@sudoku/stores/grid';


function CreateHistoryManager() {
  // 本地 recordAction 实现，供回溯/其他路径复用
  function recordActionLocal(action) {
    if (!action) return;
    try {
      console.debug('[historyManager.recordAction] action recorded', { action: action && action.constructor && action.constructor.name, currentNodeCreatedAt: historyDGA.current && historyDGA.current.createdAt, incoming: historyDGA.current && historyDGA.current.incomingEdges && historyDGA.current.incomingEdges.length, outgoing: historyDGA.current && historyDGA.current.outgoingEdges && historyDGA.current.outgoingEdges.length });
    } catch (e) {}
    syncBooleans();
  }

  return {
    // 状态访问
    getBranchBackTimes: () => historyState.branchBackTimes,
    // 兼容旧接口（返回布尔 store），推荐使用 getCanUndo/getCanRedo/getCanBacktrack
    getUndoCount: () => historyState.canUndo,
    getRedoCount: () => historyState.canRedo,
    // 直接返回布尔 store，便于组件订阅
    getCanUndo: () => historyState.canUndo,
    getCanRedo: () => historyState.canRedo,
    getCanBacktrack: () => historyState.canBacktrack,

    // 基础原语（保持兼容此前接口）
    gotoTimeStep,
    rollbackAllCellsTo,
    refreshAfterTimeTravel: (opts) => {
      recomputeCandidates();
      refreshAfterTimeTravel(opts);
    },

    

    
    createHintAction,
    createFillAction,
    // 导出 DOT 文本用于调试/可视化
    getHistoryDot: () => {
      try { return historyDGA.toDOT(); } catch (e) { return null; }
    },

    // 回溯并记录到撤销/重做栈
    backtrackWithRecord: () => {
      if (get(historyState.branchBackTimes) <= 0) return false;

      const action = createBacktrackAction({ fromTimeStep: 0, toTimeStep: 0 });
      const ok = action.apply();
      if (ok) {
        // 记录动作并同步布尔 stores
        recordActionLocal(action);
      }
      return ok;
    },

    // 撤销/重做
    undoStep: () => {
      // 优先通过 DAG 获取最近的入边（edge）并使用其 action
      const edge = historyDGA.canUndo();
      let action = null;
      if (edge && edge.action) {
        action = edge.action;
      } 

      if (action) {
        try {
          const ok = action.undo();
          if (ok) {
            syncBooleans();
            return ok;
          }
        } catch (e) {
          console.debug('[historyManager.undoStep] action.undo failed, falling back to DGA', e);
        }
      }

      // fallback: move DGA pointer and restore node state
      const node = historyDGA.undoStep();
      if (!node) return false;
      try { applyBoardStateToLive(node.state); } catch (e) { console.error('[historyManager.undoStep] applyBoardStateToLive failed', e); }
      syncBooleans();
      return true;
    },


    redoStep: () => {
      // 优先通过 DAG 获取最近的出边（edge）并使用其 action
      const edge = historyDGA.canRedo();
      try { console.debug('[historyManager.redoStep] computed edge', edge); } catch (e) {}
      let action = null;
      if (edge && edge.action) {
        action = edge.action;
      } 

      if (action) {
        try {
          const ok = action.redo();
          if (ok) {
            syncBooleans();
            return ok;
          }
        } catch (e) {
          console.debug('[historyManager.redoStep] action.redo failed, falling back to DGA', e);
        }
      }

      // fallback: use DGA redo primitive and apply snapshot
      const node = historyDGA.redoStep();
      if (!node) return false;
      try { applyBoardStateToLive(node.state); } catch (e) { console.error('[historyManager.redoStep] applyBoardStateToLive failed', e); }
      syncBooleans();
      return true;
    },

    // 记录一个已成功应用的 action（由 UI 层在 action.apply() 返回 true 后调用）
    recordAction: (action) => {
      if (!action) return;
      // 新动作记录后，同步布尔 stores
      try {
        console.debug('[historyManager.recordAction] action recorded', { action: action && action.constructor && action.constructor.name, currentNodeCreatedAt: historyDGA.current && historyDGA.current.createdAt, incoming: historyDGA.current && historyDGA.current.incomingEdges && historyDGA.current.incomingEdges.length, outgoing: historyDGA.current && historyDGA.current.outgoingEdges && historyDGA.current.outgoingEdges.length });
      } catch (e) {}
      syncBooleans();
    },

    // 状态查询（兼容旧接口，返回布尔）
    canBacktrack: () => !!historyDGA.canBacktrack(),
    canUndo: () => !!historyDGA.canUndo(),
    canRedo: () => !!historyDGA.canRedo(),
  };
}

// 辅助：同步 historyState 中的布尔 stores（由 manager 调用）
function syncBooleans() {
  try {
    const canUndo = !!historyDGA.canUndo();
    const canRedo = !!historyDGA.canRedo();
    // Prefer authoritative branch count for backtrack availability.
    // historyState.branchBackTimes is the UI-visible counter and should
    // drive whether Backtrack is enabled. Using historyDGA.canBacktrack()
    // could allow the button to be enabled when branch count is zero.
    const branchCount = get(historyState.branchBackTimes) || 0;
    const canBacktrack = branchCount > 0;
    try { console.debug('[historyManager.syncBooleans] computed', { canUndo, canRedo, canBacktrack, currentNodeCreatedAt: historyDGA.current && historyDGA.current.createdAt, incoming: historyDGA.current && historyDGA.current.incomingEdges && historyDGA.current.incomingEdges.length, outgoing: historyDGA.current && historyDGA.current.outgoingEdges && historyDGA.current.outgoingEdges.length }); } catch (e) {}
    historyState.canUndo.set(canUndo);
    historyState.canRedo.set(canRedo);
    historyState.canBacktrack.set(canBacktrack);
  } catch (err) {
    // ignore
  }
}

const historyManager = CreateHistoryManager();
// 初始同步
syncBooleans();

// 在浏览器环境下暴露一个便捷函数，允许在控制台直接输入 __historyDOT() 获取 DOT 文本
try {
  if (typeof window !== 'undefined') {
    window.__historyDOT = () => historyManager.getHistoryDot();
    // Dump current history node and short summaries of node state and live grids
    window.__historyDump = () => {
      const out = { summary: null, traceInfo: null, nodeState: null, liveUser: null, liveStrategyFingerprint: null };
      try {
        const cur = historyDGA.current;
        out.summary = {
          currentCreatedAt: cur && cur.createdAt,
          lastAccessedAt: cur && cur.lastAccessedAt,
          incoming: cur && cur.incomingEdges && cur.incomingEdges.length,
          outgoing: cur && cur.outgoingEdges && cur.outgoingEdges.length,
          traceFrom: cur && cur.traceFrom && cur.traceFrom.createdAt,
          hasTraceEdges: !!(cur && cur.traceEdges),
        };

        // node state summary (userGrid first row fingerprint)
        try {
          if (cur && cur.state && cur.state.userGrid && Array.isArray(cur.state.userGrid) && cur.state.userGrid[0]) {
            out.nodeState = { nodeUserRow0: cur.state.userGrid[0].slice(0,9).join(',') };
          }
        } catch (e) {
          out.nodeState = null;
          console.warn('__historyDump: failed to summarize node.state.userGrid', e);
        }

        // live user grid fingerprint
        try {
          const ug = get(userGrid);
          if (ug && ug[0]) out.liveUser = ug[0].slice(0,9).join(',');
        } catch (e) {
          out.liveUser = null;
          console.warn('__historyDump: failed to read userGrid', e);
        }

        // live strategy fingerprint
        try {
          const sg = get(strategyGrid.getStrategyGrid());
          if (sg && sg[0]) out.liveStrategyFingerprint = sg[0].map(c => c.explore || 0).slice(0,9).join(',');
        } catch (e) {
          out.liveStrategyFingerprint = null;
          console.warn('__historyDump: failed to read strategyGrid', e);
        }

        // traceEdges info
        try {
          const curTrace = cur && cur.traceEdges ? cur.traceEdges : null;
          if (curTrace) {
            out.traceInfo = {
              from: curTrace.from && curTrace.from.createdAt,
              to: curTrace.to && curTrace.to.createdAt,
              hasAction: !!curTrace.action,
              actionName: curTrace.action && curTrace.action.constructor && curTrace.action.constructor.name,
              hasRedo: !!(curTrace.action && typeof curTrace.action.redo === 'function'),
              hasUndo: !!(curTrace.action && typeof curTrace.action.undo === 'function'),
            };
          }
        } catch (e) {
          out.traceInfo = null;
          console.warn('__historyDump: failed to read traceEdges', e);
        }

        console.log('--- __historyDump ---');
        console.log('summary:', out.summary);
        console.log('traceInfo:', out.traceInfo);
        console.log('nodeState (user row0):', out.nodeState && out.nodeState.nodeUserRow0);
        console.log('liveUser row0:', out.liveUser);
        console.log('liveStrategy row0.explore:', out.liveStrategyFingerprint);
        return out;
      } catch (err) {
        console.error('__historyDump failed', err);
        return out;
      }
    };
    // Expose manager and DGA to the global window for console debugging
    try {
      window.historyManager = historyManager;
      window.historyDGA = historyDGA;
    } catch (e) {
      console.warn('Could not attach historyManager/historyDGA to window', e);
    }
    // Inspect raw DGA and edge objects for debugging
    window.__historyInspect = () => {
      try {
        const edge = historyDGA.canRedo();
        const cur = historyDGA.current;
        return {
          currentCreatedAt: cur && cur.createdAt,
          canRedoEdge: edge || null,
          traceEdges: cur && cur.traceEdges ? cur.traceEdges : null,
          rootDot: historyManager.getHistoryDot(),
        };
      } catch (e) {
        console.error('__historyInspect failed', e);
        return null;
      }
    };
  }
} catch (e) {}

export { historyManager };
