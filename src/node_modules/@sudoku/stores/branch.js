import { get } from 'svelte/store';
import { historyState } from './history/state';
import { createHintAction, createFillAction, createBacktrackAction } from './history/commands';
import { gotoTimeStep, recomputeCandidates, rollbackAllCellsTo, refreshAfterTimeTravel } from './history/helpers';
import { strategyGrid } from '@sudoku/stores/grid';


function CreateHistoryManager() {
  return {
    // 状态访问
    getBranchBackTimes: () => historyState.branchBackTimes,
    getBranchBackTimeSteps: () => historyState.branchBackTimeSteps,
    getUndoCount: () => historyState.undoCount,
    getRedoCount: () => historyState.redoCount,

    // 基础原语（保持兼容此前接口）
    gotoTimeStep,
    rollbackAllCellsTo,
    refreshAfterTimeTravel: (opts) => {
      recomputeCandidates();
      refreshAfterTimeTravel(opts);
    },

    // 分支标记
    markBranchAtCurrentStep: () => {
      const ts = get(strategyGrid.getTimeStep());
      historyState.addBranch(ts);
    },

    // 命令管理
    recordAction: (action) => {
      historyState.pushUndo(action);
      historyState.clearRedo();
    },
    createHintAction,
    createFillAction,

    // 回溯并记录到撤销/重做栈
    backtrackWithRecord: () => {
      if (get(historyState.branchBackTimes) <= 0) return false;
      const targetTimeStep = historyState.peekBranch() ?? 0;
      const fromTimeStep = get(strategyGrid.getTimeStep());
      const action = createBacktrackAction({ fromTimeStep, toTimeStep: targetTimeStep });
      const ok = action.apply();
      if (ok) historyState.pushUndo(action), historyState.clearRedo();
      return ok;
    },

    // 撤销/重做
    undoStep: () => {
      const action = historyState.popUndo();
      if (!action) return false;
      const ok = action.undo();
      if (ok) historyState.pushRedo(action);
      return ok;
    },

    redoStep: () => {
      const action = historyState.popRedo();
      if (!action) return false;
      const ok = action.apply();
      if (ok) historyState.pushUndo(action);
      return ok;
    },

    // 状态查询
    canBacktrack: () => get(historyState.branchBackTimes) > 0,
    canUndo: () => historyState.undoStack.length > 0,
    canRedo: () => historyState.redoStack.length > 0,
  };
}

export const historyManager = CreateHistoryManager();
