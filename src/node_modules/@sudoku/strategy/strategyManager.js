import { hs } from '@sudoku/strategy/hiddenSingleStrategy';
import { np } from '@sudoku/strategy/nakedPairsStrategy';
import { ns2, ns3, ns4 } from '@sudoku/strategy/nakedSubsetsStrategy';
import { pp } from '@sudoku/strategy/pointingPairsStrategy';
import { hp } from '@sudoku/strategy/hiddenCandidatesStrategy';
import { bug } from '@sudoku/strategy/bugStrategy';
import { writable } from 'svelte/store';
import { strategyGrid } from '@sudoku/stores/grid';

/**
 * 策略管理器
 * 负责管理所有策略，按照优先级顺序应用策略
 */
function CreateStrategyManager() {
  const strategiesSet = [];
  const isUsingStrategy = writable(false);
  const isGenerateSingleCandidate = writable(false);
  // 记录最近一次策略应用影响的格子集合（{x,y} 数组）
  let lastAppliedPositions = [];
  // 按时间步记录 lastAppliedPositions 的快照：{ [timeStep]: [{x,y}, ...] }
  const lastAppliedTimeline = {};

  return {
    /**
     * 添加新策略
     * @param {BaseStrategy} strategy - 策略实例
     * @param {number} priority - 策略优先级
     */
    addNewStrategy: (strategy, priority) => {
      strategiesSet.push({strategy: strategy, priority: priority});
      strategiesSet.sort((a, b) => a.priority - b.priority);
    },

    /**
     * 应用策略，按优先级依次尝试，每次只产生一个提示数字
     * 如果低复杂度策略有结果则立即返回，不再尝试更高复杂度的策略
     * @param {Array} grid - 策略网格
     * @returns {Array} - 应用策略的单元格位置数组（只包含产生提示的单元格）
     */
    apply: (grid) => {
      isGenerateSingleCandidate.set(false);
      // 重置相对位置和策略
      grid.map(row => row.map(cell => { 
        cell.resetRelativePos(); 
        cell.resetStrategies(); 
      }));

      const allAffectedCells = [];
      
      let foundAny = false;
      // 按优先级顺序依次尝试策略
      for (const { strategy } of strategiesSet) {
        // 检查策略的前置条件
        // [fix] yyy: 策略需要反复应用，原来用if，现在改成while
        while (strategy.preCondition(grid)) {
          // 记录应用策略前的单元格数量
          const beforeLength = allAffectedCells.length;
          
          // 应用策略
          strategy.apply(grid, allAffectedCells);
          
          // 检查本次策略应用后，是否有单元格的候选数变成了1（产生了确定的结果）
          // 只取第一个产生单个候选数的单元格作为提示
          console.log('allAffectedCells after applying', strategy.strategyDescription(), allAffectedCells);
          for (let i = beforeLength; i < allAffectedCells.length; i++) {
            const pos = allAffectedCells[i];
            if (grid[pos.y][pos.x].candidates.length === 1) {
              grid[pos.y][pos.x].explore = grid[pos.y][pos.x].candidates[0];
              isGenerateSingleCandidate.set(true);
              // [FIXME] yyy: 如果只返回第一个，可能在策略实施的时候确定了两个单元格，但是src/components/Board/index.svelte中的显示逻辑是根据grid的状态的
              // 最终会导致只显示一个单元格的explore，另一个单元格标亮，但是没有显示数，造成显示bug
              
              foundAny = true;
              // break;
            }
          }
          strategyGrid.printCandidates();
          if (foundAny) {return allAffectedCells.filter(p => grid[p.y][p.x].candidates.length === 1);}
        }
      }
      
      strategyGrid.printCandidates();
      // 兜底检查, 防止遗漏，同时若实在没有确定结果，返回所有可能的值
      const unique = [];
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
          const cell = grid[y][x];
          if (!cell.isCellConstant() && Array.isArray(cell.candidates) && cell.candidates.length === 1) {
            lastAppliedPositions = [{ x, y }];
            for (const { strategy } of strategiesSet) {
              cell.strategies.push(strategy);
            }
            cell.explore = cell.candidates[0];
            isGenerateSingleCandidate.set(true);
            return [{ x, y }];
          }
          if (!cell.isCellConstant() && Array.isArray(cell.candidates) && cell.candidates.length > 0) {
            console.debug('[strategyManager] lastAppliedPositions add', { x, y }, "candidates:", cell.candidates);
            for (const { strategy } of strategiesSet) {
              cell.strategies.push(strategy);
            }
            unique.push({ x, y });
          }
        }
      }

      lastAppliedPositions = unique;
      console.debug('[strategyManager] lastAppliedPositions set (all non-constant with candidates>0)', lastAppliedPositions);
      return unique;
    },

    /**
     * 为指定时间步保存当前的 lastAppliedPositions 快照
     * @param {number} timeStep
     * @param {Array} positions - 可选，如果提供则以此为快照内容
     */
    snapshotLastApplied: (timeStep, positions = null) => {
      lastAppliedTimeline[timeStep] = positions ? positions.map(p => ({ x: p.x, y: p.y })) : lastAppliedPositions.map(p => ({ x: p.x, y: p.y }));
      console.debug('[strategyManager] snapshotLastApplied', timeStep, lastAppliedTimeline[timeStep]);
    },

    /**
     * 跳转到指定时间步并恢复该时间步的 lastAppliedPositions
     * @param {number} timeStep
     */
    gotoTimeStep: (timeStep) => {
      if (timeStep in lastAppliedTimeline) {
        lastAppliedPositions = lastAppliedTimeline[timeStep].map(p => ({ x: p.x, y: p.y }));
      } else {
        lastAppliedPositions = [];
      }
      console.debug('[strategyManager] gotoTimeStep restored', timeStep, lastAppliedPositions);
    },

    /**
     * 判断指定位置是否在最近一次策略应用的受影响位置中
     * @param {number} y
     * @param {number} x
     */
    isPositionInLastApplied: (y, x) => {
      return lastAppliedPositions.some(p => p.x === x && p.y === y);
    },

    /**
     * 获取最近一次策略应用的受影响位置（只读副本）
     */
    getLastAppliedPositions: () => [...lastAppliedPositions],

    /**
     * 获取是否使用策略的状态
     */
    getIsUsingStrategy: () => {
      return {
        subscribe: isUsingStrategy.subscribe,

        set(val) {
          isUsingStrategy.set(val);
        },

        reset() {
          isUsingStrategy.set(false);
        }
      };
    },

    /**
     * 获取是否生成单个候选数的状态
     */
    getIsGenerateSingleCandidate: () => isGenerateSingleCandidate,
  };
}

export const strategyManager = CreateStrategyManager();

// 按优先级顺序添加策略
strategyManager.addNewStrategy(hs, hs.priority);   
strategyManager.addNewStrategy(ns2, ns2.priority); // 优先级2
strategyManager.addNewStrategy(ns3, ns3.priority); // 优先级3
strategyManager.addNewStrategy(ns4, ns4.priority); // 优先级4

// strategyManager.addNewStrategy(pp, pp.priority);   优先级3
// strategyManager.addNewStrategy(hp, hp.priority);   优先级4
// strategyManager.addNewStrategy(bug, bug.priority); // 优先级5

