import { hs } from '@sudoku/strategy/hiddenSingleStrategy';
import { np } from '@sudoku/strategy/nakedPairsStrategy';
import { ns2, ns3, ns4 } from '@sudoku/strategy/nakedSubsetsStrategy';
import { pp } from '@sudoku/strategy/pointingPairsStrategy';
import { hp } from '@sudoku/strategy/hiddenCandidatesStrategy';
import { bug } from '@sudoku/strategy/bugStrategy';
import { writable, get } from 'svelte/store';
import { strategyGrid } from '@sudoku/stores/grid';

/**
 * 策略管理器
 * 负责管理所有策略，按照优先级顺序应用策略
 */
function CreateStrategyManager() {
  const strategiesSet = [];
  const isUsingStrategy = writable(false);
  const isGenerateSingleCandidate = writable(false);
  // 记录最近一次策略应用影响的格子集合（{x,y} 数组）
  let lastAppliedPositions = [];
  // 按时间步记录 lastAppliedPositions 的快照：{ [timeStep]: [{x,y}, ...] }
  const lastAppliedTimeline = {};

  return {
    /**
     * 添加新策略
     * @param {BaseStrategy} strategy - 策略实例
     * @param {number} priority - 策略优先级
     */
    addNewStrategy: (strategy, priority) => {
      strategiesSet.push({strategy: strategy, priority: priority});
      strategiesSet.sort((a, b) => a.priority - b.priority);
    },

    /**
     * 应用策略，按优先级依次尝试，每次只产生一个提示数字
     * 如果低复杂度策略有结果则立即返回，不再尝试更高复杂度的策略
     * @param {Array} grid - 策略网格
     * @returns {Array} - 应用策略的单元格位置数组（只包含产生提示的单元格）
     */
    apply: (grid) => {
      isGenerateSingleCandidate.set(false);
      // 1. 重置 UI 状态
      grid.map(row => row.map(cell => { 
        cell.resetRelativePos(); 
        cell.resetStrategies(); 
      }));

      const allAffectedCells = [];
      
      // 按优先级顺序依次尝试策略
      for (const { strategy } of strategiesSet) {
        // 检查策略的前置条件
        // [fix] yyy: 策略需要反复应用，原来用if，现在改成while
        while (strategy.preCondition(grid)) {
          const beforeLength = allAffectedCells.length;
          
          // 应用策略
          strategy.apply(grid, allAffectedCells);
          
          // 检查本次迭代是否产生了新的解
          let stepSolved = [];
          for (let i = beforeLength; i < allAffectedCells.length; i++) {
            const pos = allAffectedCells[i];
            if (grid[pos.y][pos.x].candidates.length === 1) {
              grid[pos.y][pos.x].explore = grid[pos.y][pos.x].candidates[0];
              isGenerateSingleCandidate.set(true);
              // [FIXME] yyy: 如果只返回第一个，可能在策略实施的时候确定了两个单元格，但是src/components/Board/index.svelte中的显示逻辑是根据grid的状态的
              // 最终会导致只显示一个单元格的explore，另一个单元格标亮，但是没有显示数，造成显示bug
              stepSolved.push(pos);
            }
          }

          // 一旦有解，同步状态并返回
          if (stepSolved.length > 0) {
            lastAppliedPositions = stepSolved; 
            return lastAppliedPositions;
          }

          // 如果 while 循环中只是删除了候选数但没有产生 length === 1
          // 也需要更新高亮，否则 UI 不会反馈消除动作
          if (allAffectedCells.length > beforeLength) {
            lastAppliedPositions = allAffectedCells.slice(beforeLength);
            // 如果想看消除过程，可以在这里 return
            // return lastAppliedPositions; 
          }
        }
      }
      
      strategyGrid.printCandidates();
      // 兜底检查, 防止遗漏，同时若实在没有确定结果，返回所有可能的值
      const unique = [];
      const singles = [];
      for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
          const cell = grid[y][x];
          if (!cell.isCellConstant() && Array.isArray(cell.candidates) && cell.candidates.length === 1) {
            singles.push({ x, y });
            for (const { strategy } of strategiesSet) {
              cell.strategies.push(strategy);
            }
            cell.explore = cell.candidates[0];
          } else if (!cell.isCellConstant() && Array.isArray(cell.candidates) && cell.candidates.length > 0) {
            console.debug('[strategyManager] lastAppliedPositions add', { x, y }, "candidates:", cell.candidates);
            for (const { strategy } of strategiesSet) {
              cell.strategies.push(strategy);
            }
            unique.push({ x, y });
          }
        }
      }

      if (singles.length > 0) {
        lastAppliedPositions = singles;
        isGenerateSingleCandidate.set(true);
        return singles;
      }

      lastAppliedPositions = unique;
      console.debug('[strategyManager] lastAppliedPositions set (all non-constant with candidates>0)', lastAppliedPositions);
      return unique;
    },

    // /**
    //  * 为指定时间步保存当前的策略网格和用户网格状态快照
    //  * @param {number} timeStep
    //  * @param {Array} strategyGridState - 可选，如果提供则以此为快照内容
    //  * @param {Array} userGridState - 可选，如果提供则以此为快照内容
    //  */
    // snapshotBoardState: (timeStep, strategyGridState = null, userGridState = null) => {
    //   lastAppliedTimeline[timeStep] = {
    //     strategyGrid: strategyGridState ? strategyGridState.map(row => row.map(cell => ({ ...cell }))) : grid.map(row => row.map(cell => ({ ...cell }))) ,
    //     userGrid: userGridState ? userGridState.map(row => row.map(cell => ({ ...cell }))) : userGrid.map(row => row.map(cell => ({ ...cell })))
    //   };
    //   console.debug('[strategyManager] snapshotBoardState', timeStep, lastAppliedTimeline[timeStep]);
    // },

    /**
     * 判断指定位置是否在最近一次策略应用的受影响位置中
     * @param {number} y
     * @param {number} x
     */
    isPositionInLastApplied: (y, x) => {
      return lastAppliedPositions.some(p => p.x === x && p.y === y);
    },

    /**
     * 获取最近一次策略应用的受影响位置（只读副本）
     */
    getLastAppliedPositions: () => [...lastAppliedPositions],

    /**
     * Restore last applied positions (used when restoring from history snapshots)
     * @param {Array} positions - array of {x,y} objects
     */
    setLastAppliedPositions: (positions) => {
      try {
        lastAppliedPositions = Array.isArray(positions) ? positions.map(p => ({ x: p.x, y: p.y })) : [];
      } catch (e) {
        lastAppliedPositions = [];
      }
    },

    /**
     * 获取是否使用策略的状态
     */
    getIsUsingStrategy: () => {
      return {
        subscribe: isUsingStrategy.subscribe,

        set(val) {
          isUsingStrategy.set(val);
        },

        reset() {
          isUsingStrategy.set(false);
        }
      };
    },

    /**
     * 获取是否生成单个候选数的状态
     */
    getIsGenerateSingleCandidate: () => isGenerateSingleCandidate,

    // /**
    //  * 获取当前策略网格和用户网格的状态
    //  * @returns {Object} 包含策略网格和用户网格状态的对象
    //  */
    // getCurrentBoardState: () => {
    //   return {
    //     strategyGrid: grid.map(row => row.map(cell => ({ ...cell }))) ,
    //     userGrid: userGrid.map(row => row.map(cell => ({ ...cell })))
    //   };
    // },
  };
}

export const strategyManager = CreateStrategyManager();

// 按优先级顺序添加策略
strategyManager.addNewStrategy(hs, hs.priority);   
strategyManager.addNewStrategy(ns2, ns2.priority); // 优先级2
strategyManager.addNewStrategy(ns3, ns3.priority); // 优先级3
strategyManager.addNewStrategy(ns4, ns4.priority); // 优先级4
strategyManager.addNewStrategy(pp, pp.priority);   // 优先级5

// strategyManager.addNewStrategy(pp, pp.priority);   优先级3
// strategyManager.addNewStrategy(hp, hp.priority);   优先级4
// strategyManager.addNewStrategy(bug, bug.priority); // 优先级5
strategyManager.addNewStrategy(hp, hp.priority);   

