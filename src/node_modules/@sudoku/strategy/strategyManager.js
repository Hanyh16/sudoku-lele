import { hs } from '@sudoku/strategy/hiddenSingleStrategy';
import { np } from '@sudoku/strategy/nakedPairsStrategy';
import { pp } from '@sudoku/strategy/pointingPairsStrategy';
import { hp } from '@sudoku/strategy/hiddenCandidatesStrategy';
import { writable } from 'svelte/store';

/**
 * 策略管理器
 * 负责管理所有策略，按照优先级顺序应用策略
 */
function CreateStrategyManager() {
  const strategiesSet = [];
  const isUsingStrategy = writable(false);
  const isGenerateSingleCandidate = writable(false);

  return {
    /**
     * 添加新策略
     * @param {BaseStrategy} strategy - 策略实例
     * @param {number} priority - 策略优先级
     */
    addNewStrategy: (strategy, priority) => {
      strategiesSet.push({strategy: strategy, priority: priority});
      strategiesSet.sort((a, b) => a.priority - b.priority);
    },

    /**
     * 应用策略，按优先级依次尝试，每次只产生一个提示数字
     * 如果低复杂度策略有结果则立即返回，不再尝试更高复杂度的策略
     * @param {Array} grid - 策略网格
     * @returns {Array} - 应用策略的单元格位置数组（只包含产生提示的单元格）
     */
    apply: (grid) => {
      isGenerateSingleCandidate.set(false);
      // 重置相对位置和策略
      grid.map(row => row.map(cell => { 
        cell.resetRelativePos(); 
        cell.resetStrategies(); 
      }));

      const allAffectedCells = [];
      
      // 按优先级顺序依次尝试策略
      for (const { strategy } of strategiesSet) {
        // 检查策略的前置条件
        if (strategy.preCondition(grid)) {
          // 记录应用策略前的单元格数量
          const beforeLength = allAffectedCells.length;
          
          // 应用策略
          strategy.apply(grid, allAffectedCells);
          
          // 检查本次策略应用后，是否有单元格的候选数变成了1（产生了确定的结果）
          // 只取第一个产生单个候选数的单元格作为提示
          for (let i = beforeLength; i < allAffectedCells.length; i++) {
            const pos = allAffectedCells[i];
            if (grid[pos.y][pos.x].candidates.length === 1) {
              grid[pos.y][pos.x].explore = grid[pos.y][pos.x].candidates[0];
              isGenerateSingleCandidate.set(true);
              // 只返回第一个产生单个候选数的单元格
              return [pos];
            }
          }
        }
      }
      
      // 如果没有产生任何单个候选数的结果，返回空数组
      return [];
    },

    /**
     * 获取是否使用策略的状态
     */
    getIsUsingStrategy: () => {
      return {
        subscribe: isUsingStrategy.subscribe,

        set(val) {
          isUsingStrategy.set(val);
        },

        reset() {
          isUsingStrategy.set(false);
        }
      };
    },

    /**
     * 获取是否生成单个候选数的状态
     */
    getIsGenerateSingleCandidate: () => isGenerateSingleCandidate,
  };
}

export const strategyManager = CreateStrategyManager();

// 按优先级顺序添加策略
strategyManager.addNewStrategy(hs, hs.priority);   
// strategyManager.addNewStrategy(np, np.priority);   优先级2
// strategyManager.addNewStrategy(pp, pp.priority);   优先级3
// strategyManager.addNewStrategy(hp, hp.priority);   优先级4

