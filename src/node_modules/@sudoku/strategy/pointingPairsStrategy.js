import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * Pointing Pairs Strategy
 * priority: 3
 * description:
 * If all candidates of a number in a box lie in the same row or column,
 * that number can be eliminated from the rest of that row or column outside the box.
 */
class PointingPairsStrategy extends BaseStrategy {
    constructor(description = "Pointing Pairs", priority = 3) {
        super();
        this.description = description;
        this.priority = priority;
    }

    preCondition(grid) {
        return this.scanGrid(grid, false);
    }

    apply(grid, strategyApplyCell) {
        return this.scanGrid(grid, true, strategyApplyCell);
    }

    strategyDescription() {
        return this.description;
    }

    /**
     * Scan all boxes for pointing pairs
     */
    scanGrid(grid, isApply, strategyApplyCell = []) {
        let anyChange = false;

        for (let b = 0; b < SUDOKU_SIZE; b++) {
            const startRow = Math.floor(b / BOX_SIZE) * BOX_SIZE;
            const startCol = (b % BOX_SIZE) * BOX_SIZE;

            const boxCells = [];

            for (let i = 0; i < BOX_SIZE; i++) {
                for (let j = 0; j < BOX_SIZE; j++) {
                    const r = startRow + i;
                    const c = startCol + j;
                    const cell = grid[r][c];
                    if (!cell.isCellConstant()) {
                        boxCells.push({ cell, x: c, y: r });
                    }
                }
            }

            const result = this.processBox(boxCells, startRow, startCol, grid, isApply, strategyApplyCell);
            if (result) {
                anyChange = true;
            }
        }

        return anyChange;
    }

    /**
     * Process one 3x3 box
     */
    processBox(boxCells, startRow, startCol, grid, isApply, strategyApplyCell) {
        let changed = false;

        // 构建数字到位置的映射
        const digitPositions = new Map();
        
        for (const cell of boxCells) {
            for (const digit of cell.cell.candidates) {
                if (!digitPositions.has(digit)) {
                    digitPositions.set(digit, []);
                }
                digitPositions.get(digit).push({ x: cell.x, y: cell.y, cell: cell.cell });
            }
        }

        // 检查每个数字是否满足指向对数条件
        for (const [digit, positions] of digitPositions.entries()) {
            // 位置少于1个无法应用策略
            if (positions.length < 1) continue;

            const digitNum = Number(digit);

            // 检查是否所有位置都在同一行
            const allSameRow = positions.every(p => p.y === positions[0].y);
            if (allSameRow) {
                const targetRow = positions[0].y;
                // 删除该行其他宫中的该数字候选
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    // 跳过当前宫的列
                    if (col >= startCol && col < startCol + BOX_SIZE) continue;

                    const cell = grid[targetRow][col];
                    if (cell.isCellConstant()) continue;

                    if (cell.candidates.some(n => Number(n) === digitNum)) {
                        if (!isApply) return true;

                        const beforeLen = cell.candidates.length;
                        cell.candidates = cell.candidates.filter(n => Number(n) !== digitNum);

                        if (cell.candidates.length < beforeLen) {
                            changed = true;
                            cell.strategies.push(this);
                            
                            // 记录证据
                            positions.forEach(p => {
                                if (!cell.relativePos.some(rp => rp.x === p.x && rp.y === p.y)) {
                                    cell.relativePos.push({ x: p.x, y: p.y });
                                }
                            });
                            
                            if (!strategyApplyCell.some(ap => ap.x === col && ap.y === targetRow)) {
                                strategyApplyCell.push({ x: col, y: targetRow });
                            }
                        }
                    }
                }
            }

            // 检查是否所有位置都在同一列
            const allSameCol = positions.every(p => p.x === positions[0].x);
            if (allSameCol) {
                const targetCol = positions[0].x;
                // 删除该列其他宫中的该数字候选
                for (let row = 0; row < SUDOKU_SIZE; row++) {
                    // 跳过当前宫的行
                    if (row >= startRow && row < startRow + BOX_SIZE) continue;

                    const cell = grid[row][targetCol];
                    if (cell.isCellConstant()) continue;

                    if (cell.candidates.some(n => Number(n) === digitNum)) {
                        if (!isApply) return true;

                        const beforeLen = cell.candidates.length;
                        cell.candidates = cell.candidates.filter(n => Number(n) !== digitNum);

                        if (cell.candidates.length < beforeLen) {
                            changed = true;
                            cell.strategies.push(this);
                            
                            // 记录证据
                            positions.forEach(p => {
                                if (!cell.relativePos.some(rp => rp.x === p.x && rp.y === p.y)) {
                                    cell.relativePos.push({ x: p.x, y: p.y });
                                }
                            });
                            
                            if (!strategyApplyCell.some(ap => ap.x === targetCol && ap.y === row)) {
                                strategyApplyCell.push({ x: targetCol, y: row });
                            }
                        }
                    }
                }
            }
        }

        return changed;
    }
}

export const pp = new PointingPairsStrategy();