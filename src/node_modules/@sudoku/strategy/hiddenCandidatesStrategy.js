import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

class HiddenPairStrategy extends BaseStrategy {
  constructor(description = "Hidden Pair", priority = 0) {
    super();
    this.description = description;
    this.priority = priority;
    this.fullSetCandidates = Array.from({ length: SUDOKU_SIZE }).map((_, i) => i + 1);
  }

  // 辅助函数：获取单元格集合中的隐藏对
  getHiddenPairsInUnit(cells) {
    let candidatePositions = {}; // 记录每个数字出现在哪些单元格索引中
    
    cells.forEach((cell, index) => {
      cell.candidates.forEach(can => {
        if (!candidatePositions[can]) candidatePositions[can] = [];
        candidatePositions[can].push(index);
      });
    });

    // 筛选出在该区域内恰好只出现 2 次的数字
    let candidatesWithTwoOccurrences = Object.keys(candidatePositions)
      .filter(can => candidatePositions[can].length === 2)
      .map(Number);

    // 在这些数字中寻找出现在相同位置的一对
    for (let i = 0; i < candidatesWithTwoOccurrences.length; i++) {
      for (let j = i + 1; j < candidatesWithTwoOccurrences.length; j++) {
        let c1 = candidatesWithTwoOccurrences[i];
        let c2 = candidatesWithTwoOccurrences[j];

        // 如果两个候选数出现的位置完全一样
        if (candidatePositions[c1][0] === candidatePositions[c2][0] &&
            candidatePositions[c1][1] === candidatePositions[c2][1]) {
          
          let idx1 = candidatePositions[c1][0];
          let idx2 = candidatePositions[c1][1];

          // 检查这两个单元格是否除了这两个候选数外还有其他数字（即是否有可消除项）
          if (cells[idx1].candidates.length > 2 || cells[idx2].candidates.length > 2) {
            return {
              hiddenPairs: [c1, c2],
              pairIndices: [idx1, idx2]
            };
          }
        }
      }
    }
    return null;
  }

  preCondition(grid) {
    // 检查 行、列、宫
    for (let i = 0; i < SUDOKU_SIZE; i++) {
      let rowCells = [], colCells = [], boxCells = [];
      let boxRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
      let boxCol = (i % BOX_SIZE) * BOX_SIZE;

      for (let j = 0; j < SUDOKU_SIZE; j++) {
        // 行
        if (!grid[i][j].isCellConstant()) rowCells.push({ x: j, y: i, candidates: grid[i][j].candidates });
        // 列
        if (!grid[j][i].isCellConstant()) colCells.push({ x: i, y: j, candidates: grid[j][i].candidates });
        // 宫
        let r = boxRow + Math.floor(j / BOX_SIZE);
        let c = boxCol + (j % BOX_SIZE);
        if (!grid[r][c].isCellConstant()) boxCells.push({ x: c, y: r, candidates: grid[r][c].candidates });
      }

      if (this.getHiddenPairsInUnit(rowCells) || 
          this.getHiddenPairsInUnit(colCells) || 
          this.getHiddenPairsInUnit(boxCells)) {
        return true;
      }
    }
    return false;
  }

  apply(grid, strategyApplyCell) {
    // 遍历所有单位（行、列、宫）进行应用
    for (let i = 0; i < SUDOKU_SIZE; i++) {
      const units = [[], [], []]; // 0:row, 1:col, 2:box
      let boxRow = Math.floor(i / BOX_SIZE) * BOX_SIZE;
      let boxCol = (i % BOX_SIZE) * BOX_SIZE;

      for (let j = 0; j < SUDOKU_SIZE; j++) {
        if (!grid[i][j].isCellConstant()) units[0].push({ x: j, y: i, candidates: [...grid[i][j].candidates] });
        if (!grid[j][i].isCellConstant()) units[1].push({ x: i, y: j, candidates: [...grid[j][i].candidates] });
        let r = boxRow + Math.floor(j / BOX_SIZE);
        let c = boxCol + (j % BOX_SIZE);
        if (!grid[r][c].isCellConstant()) units[2].push({ x: c, y: r, candidates: [...grid[r][c].candidates] });
      }

      units.forEach(unitCells => {
        let result = this.getHiddenPairsInUnit(unitCells);
        if (result) {
          let { hiddenPairs, pairIndices } = result;
          let hiddenPairsAxis = [];

          // 执行剪枝：在这两个单元格中只保留那两个候选数
          pairIndices.forEach(idx => {
            let cell = unitCells[idx];
            grid[cell.y][cell.x].candidates = grid[cell.y][cell.x].candidates.filter(c => hiddenPairs.includes(c));
            grid[cell.y][cell.x].strategies.push(this);
            hiddenPairsAxis.push({ x: cell.y, y: cell.x});
            strategyApplyCell.push({ x: cell.y, y: cell.x });
          });

          // 设置 relativePos (该单位内除这两个格子的其他未填格)
          pairIndices.forEach(idx => {
            let targetCell = unitCells[idx];
            unitCells.forEach((otherCell, oIdx) => {
              if (oIdx !== pairIndices[0] && oIdx !== pairIndices[1]) {
                grid[targetCell.y][targetCell.x].relativePos.push({ x: otherCell.x, y: otherCell.y });
              }
            });
          });
        }
      });
    }
  }

  strategyDescription() {
    return this.description;
  }
}

export const hp = new HiddenPairStrategy();