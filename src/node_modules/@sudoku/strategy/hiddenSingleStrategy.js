import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

/**
 * 隐藏单数策略（Hidden Single Strategy）
 * 优先级：1
 * 描述：当某个数字在某行、某列或某宫中只能出现在一个位置时，该位置就是这个数字
 */
class HiddenSingleStrategy extends BaseStrategy {
  constructor(description = "Hidden Single", priority = 1) {
    super();
    this.description = description;
    this.priority = priority;
  }

  /**
   * 判断两个位置是否在同一宫格内
   */
  isSameBox(pos1, pos2) {
    return Math.floor(pos1.y / BOX_SIZE) === Math.floor(pos2.y / BOX_SIZE)
      && Math.floor(pos1.x / BOX_SIZE) === Math.floor(pos2.x / BOX_SIZE);
  }

  /**
   * 检查是否满足隐藏单数策略的前置条件
   */
  preCondition(grid) {
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        // [FIXME] yyy：这里为什么要跳过候选数为1的单元格？这会造成策略的错误，因为有些策略剪枝了候选数为1个，但是还没有显示出来，所以这里不应该跳过
        // 最好的办法就是在加一个nakedSingle策略，专门处理候选数为1的单元格
        // if (grid[row][col].isCellConstant() || grid[row][col].candidates.length === 1) continue;
        if (grid[row][col].isCellConstant()) continue;

        // 检查同一行
        let sameRowOtherCellCandidatesArray = grid[row]
          .filter((cell, index) => !cell.isCellConstant() && index !== col)
          .map(cell => cell.candidates)
          .flat();
        let sameRowOtherCellCandidatesSet = new Set(sameRowOtherCellCandidatesArray);

        let leftSameRowCandidates = grid[row][col].candidates.filter(
          candidate => !sameRowOtherCellCandidatesSet.has(candidate)
        );
        if (leftSameRowCandidates.length === 1) {
          return true;
        }

        // 检查同一列
        let sameColOtherCellCandidatesArray = grid
          .filter((cellRow, index) => !cellRow[col].isCellConstant() && index !== row)
          .map(cellRow => cellRow[col].candidates)
          .flat();
        let sameColOtherCellCandidatesSet = new Set(sameColOtherCellCandidatesArray);

        let leftSameColCandidates = grid[row][col].candidates.filter(
          candidate => !sameColOtherCellCandidatesSet.has(candidate)
        );
        if (leftSameColCandidates.length === 1) {
          return true;
        }

        // 检查同一宫
        let sameBoxOtherCellCandidatesSet = new Set();
        let startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
        let startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
          for (let j = startCol; j < startCol + BOX_SIZE; j++) {
            if (!(i === row && j === col) && !grid[i][j].isCellConstant()) {
              for (const candidate of grid[i][j].candidates) {
                sameBoxOtherCellCandidatesSet.add(candidate);
              }
            }
          }
        }
        let leftSameBoxCandidates = grid[row][col].candidates.filter(
          candidate => !sameBoxOtherCellCandidatesSet.has(candidate)
        );
        if (leftSameBoxCandidates.length === 1) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * 应用隐藏单数策略
   */
  apply(grid, strategyApplyCell) {
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        // if (grid[row][col].isCellConstant() || grid[row][col].candidates.length === 1) continue;
        if (grid[row][col].isCellConstant()) continue;

        // 同一行检查
        let sameRowOtherCellCandidatesArray = grid[row]
          .filter((cell, index) => !cell.isCellConstant() && index !== col)
          .map(cell => cell.candidates)
          .flat();
        let sameRowOtherCellCandidatesSet = new Set(sameRowOtherCellCandidatesArray);

        let leftSameRowCandidates = grid[row][col].candidates.filter(
          candidate => !sameRowOtherCellCandidatesSet.has(candidate)
        );
        if (leftSameRowCandidates.length === 1) {
          grid[row][col].candidates = leftSameRowCandidates;
          this.updateRelativePositions(grid, row, col, leftSameRowCandidates[0], 'row');
          grid[row][col].strategies.push(this);
          strategyApplyCell.push({x: col, y: row});
          continue;
        }

        // 同一列检查
        let sameColOtherCellCandidatesArray = grid
          .filter((cellRow, index) => !cellRow[col].isCellConstant() && index !== row)
          .map(cellRow => cellRow[col].candidates)
          .flat();
        let sameColOtherCellCandidatesSet = new Set(sameColOtherCellCandidatesArray);

        let leftSameColCandidates = grid[row][col].candidates.filter(
          candidate => !sameColOtherCellCandidatesSet.has(candidate)
        );
        if (leftSameColCandidates.length === 1) {
          grid[row][col].candidates = leftSameColCandidates;
          this.updateRelativePositions(grid, row, col, leftSameColCandidates[0], 'col');
          grid[row][col].strategies.push(this);
          strategyApplyCell.push({x: col, y: row});
          continue;
        }

        // 同一宫检查
        let sameBoxOtherCellCandidatesSet = new Set();
        let startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
        let startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
          for (let j = startCol; j < startCol + BOX_SIZE; j++) {
            if (!(i === row && j === col) && !grid[i][j].isCellConstant()) {
              for (const candidate of grid[i][j].candidates) {
                sameBoxOtherCellCandidatesSet.add(candidate);
              }
            }
          }
        }

        let leftSameBoxCandidates = grid[row][col].candidates.filter(
          candidate => !sameBoxOtherCellCandidatesSet.has(candidate)
        );
        if (leftSameBoxCandidates.length === 1) {
          grid[row][col].candidates = leftSameBoxCandidates;
          this.updateRelativePositions(grid, row, col, leftSameBoxCandidates[0], 'box');
          grid[row][col].strategies.push(this);
          strategyApplyCell.push({x: col, y: row});
        }
      }
    }
  }

  /**
     * 更新相关位置信息
     */
    updateRelativePositions(grid, row, col, candidate, type) {
      if (type === 'row') {
        for (let c = 0; c < SUDOKU_SIZE; c++) {
          if (c === col) continue;
          if ((grid[row][c].isCellConstant() && grid[row][c].getCurrentCell() === candidate)
            || (!grid[row][c].isCellConstant() && grid[row][c].candidates.length === 1 
              && grid[row][c].candidates[0] === candidate)) {
            grid[row][col].relativePos.push({x: c, y: row});
          }
        }
      } else if (type === 'col') {
        for (let r = 0; r < SUDOKU_SIZE; r++) {
          if (r === row) continue;
          if ((grid[r][col].isCellConstant() && grid[r][col].getCurrentCell() === candidate)
            || (!grid[r][col].isCellConstant() && grid[r][col].candidates.length === 1 
              && grid[r][col].candidates[0] === candidate)) {
            grid[row][col].relativePos.push({x: col, y: r});
          }
        }
      } else if (type === 'box') {
        let startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
        let startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
        
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
          for (let j = startCol; j < startCol + BOX_SIZE; j++) {
            if (i === row && j === col) continue;
            if ((grid[i][j].isCellConstant() && grid[i][j].getCurrentCell() === candidate)
              || (!grid[i][j].isCellConstant() && grid[i][j].candidates.length === 1 
                && grid[i][j].candidates[0] === candidate)) {
              grid[row][col].relativePos.push({x: j, y: i});
            }
          }
        }
      }
    }

  strategyDescription() {
    return this.description;
  }
}

export const hs = new HiddenSingleStrategy();

