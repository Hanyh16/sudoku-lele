/**
 * @file BUGStrategy.js
 * @author yyy
 * @description Implements the BUG (Bivalue Universal Grave) strategy for Sudoku puzzles.
 * @date 2025-12-26
 */
import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * BUG Strategy
 * priority: 99
 * description: Identifies Bivalue Universal Grave situations in Sudoku puzzles.
 */
class BUGStrategy extends BaseStrategy {
  constructor(description = "BUG Strategy", priority = 99) {
    super();
    this.description = description;
    this.priority = priority;
  }

  preCondition(grid) {
    return this.scanGrid(grid, false);
  }

  apply(grid, strategyApplyCell) {
    return this.scanGrid(grid, true, strategyApplyCell);
  }

  strategyDescription() {
    return this.description;
  }

  /**
   * scan the entire grid for BUG situations
   * @param {boolean} isApply - if true, apply the changes to the grid
   * @param {Array} strategyApplyCell - array to record the cells that were changed 
   */
    scanGrid(grid, isApply, strategyApplyCell = []) {
    let bugCell = null;
    let unsolvedCells = [];
 
    for (let r = 0; r < SUDOKU_SIZE; r++) {
      for (let c = 0; c < SUDOKU_SIZE; c++) {
        const cell = grid[r][c];
        if (cell.isCellConstant() || cell.candidates.length === 1) continue;

        // if cell has candidates other than 2 or 3, not a BUG situation
        if (cell.candidates.length < 2 || cell.candidates.length > 3) {
          return false; 
        }

        if (cell.candidates.length === 3) {
          // BUG has only one cell with 3 candidates
          if (bugCell !== null) return false; 
          bugCell = { r, c, cell };
        }
        unsolvedCells.push({ r, c, cell });
      }
    }

    if (!bugCell) return false;

    const { r, c, cell } = bugCell;
    let targetValue = null;

    for (const candidate of cell.candidates) {
      let rowCount = 0;
      let colCount = 0;
      let boxCount = 0;

      // check rows
      for (let i = 0; i < SUDOKU_SIZE; i++) {
        if (!grid[r][i].isCellConstant() && grid[r][i].candidates.includes(candidate)) {
          rowCount++;
        }
      }

      // check columns
      for (let i = 0; i < SUDOKU_SIZE; i++) {
        if (!grid[i][c].isCellConstant() && grid[i][c].candidates.includes(candidate)) {
          colCount++;
        }
      }

      // check boxes
      const startRow = Math.floor(r / BOX_SIZE) * BOX_SIZE;
      const startCol = Math.floor(c / BOX_SIZE) * BOX_SIZE;
      for (let i = startRow; i < startRow + BOX_SIZE; i++) {
        for (let j = startCol; j < startCol + BOX_SIZE; j++) {
          if (!grid[i][j].isCellConstant() && grid[i][j].candidates.includes(candidate)) {
            boxCount++;
          }
        }
      }

      // BUG principle: the number that appears 3 times in the row, column, and box is the solution
      if (rowCount === 3 && colCount === 3 && boxCount === 3) {
        targetValue = candidate;
        break;
      }
    }

    if (targetValue !== null) {
      if (!isApply) return true;

      const oldCandidates = [...cell.candidates];
      cell.candidates = [targetValue];
      cell.strategies.push(this);
      strategyApplyCell.push({ x: c, y: r });

      // record evidence positions
      this.updateRelativePositions(grid, r, c, targetValue, 'row');
      this.updateRelativePositions(grid, r, c, targetValue, 'col');
      this.updateRelativePositions(grid, r, c, targetValue, 'box');

      return true;
    }

    return false;
  }
}

export const bug = new BUGStrategy();