/**
 * @file Naked Subsets Strategy for Sudoku Solver
 * @author yyy
 * @description Implements the Naked Subsets strategy (Naked Pairs, Triples, Quads) to eliminate candidates in Sudoku puzzles.
 * @date 2025-12-29
 */
import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

class NakedSubsetsStrategy extends BaseStrategy {
    constructor(size, description, priority) {
        super();
        this.size = size; // 2, 3, or 4
        this.description = description;
        this.priority = priority;
    }

    preCondition(grid) {
        return this.scanGrid(grid, false);
    }

    apply(grid, strategyApplyCell) {
        return this.scanGrid(grid, true, strategyApplyCell);
    }

    strategyDescription() {
        return this.description;
    }

    /**
     * Get combinations of k elements from an array
     */
    getCombinations(array, k) {
        const result = [];
        const helper = (start, combo) => {
            if (combo.length === k) {
                result.push([...combo]);
                return;
            }
            for (let i = start; i < array.length; i++) {
                combo.push(array[i]);
                helper(i + 1, combo);
                combo.pop();
            }
        };
        helper(0, []);
        return result;
    }

    processUnit(unit, isApply, strategyApplyCell) {
        let changed = false;

        // the number of candidates in the cells should be between 2 and size
        const possibleCells = unit.filter(item =>
            !item.cell.isCellConstant() &&
            item.cell.candidates.length >= 2 &&
            item.cell.candidates.length <= this.size
        );

        if (possibleCells.length < this.size) return false;

        const combinations = this.getCombinations(possibleCells, this.size);

        for (const combo of combinations) {
            // calculate the union of candidates in the combination
            const unionCandidates = new Set();
            combo.forEach(item => {
                item.cell.candidates.forEach(c => unionCandidates.add(c));
            });

            // if the size of the union equals the size of the combination, we found a naked subset (this is the key condition)
            if (unionCandidates.size === this.size) {
                const numsToRemove = Array.from(unionCandidates);
                const comboCells = combo.map(item => item.cell);

                // Remove these candidates from other cells in the unit
                for (const targetItem of unit) {
                    const targetCell = targetItem.cell;
                    if (!comboCells.includes(targetCell) && !targetCell.isCellConstant()) {

                        if (targetCell.candidates.some(n => numsToRemove.includes(n))) {
                            if (!isApply) return true;

                            const beforeLen = targetCell.candidates.length;
                            targetCell.candidates = targetCell.candidates.filter(n => !numsToRemove.includes(n));

                            if (targetCell.candidates.length < beforeLen) {
                                changed = true;
                                targetCell.strategies.push(this);

                                // record evidence positions
                                combo.forEach(item => {
                                    if (!targetCell.relativePos.some(p => p.x === item.x && p.y === item.y)) {
                                        targetCell.relativePos.push({ x: item.x, y: item.y });
                                    }
                                });

                                // no need to use some to remove duplicates, indicating this cell has been modified again, otherwise strategyManager will not record multiple times
                                strategyApplyCell.push({ x: targetItem.x, y: targetItem.y });
                                // console.log(`${this.description} modified cell:`, targetItem);
                            }
                        }
                    }
                }
                if (changed){
                    return true;
                } 
            }
        }
        return changed;
    }

    /**
     * scan the entire grid for naked pairs
     * @param {boolean} isApply - if true, apply the changes to the grid
     * @param {Array} strategyApplyCell - array to record the cells that were changed
     */
    scanGrid(grid, isApply, strategyApplyCell = []) {

        // check rows
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            const rowUnit = grid[r].map((cell, c) => ({ cell, x: c, y: r }));
            if (this.processUnit(rowUnit, isApply, strategyApplyCell)) return true;
        }

        // check columns
        for (let c = 0; c < SUDOKU_SIZE; c++) {
            const colUnit = grid.map((row, r) => ({ cell: row[c], x: c, y: r }));
            if (this.processUnit(colUnit, isApply, strategyApplyCell)) return true;
        }

        // check boxes
        for (let b = 0; b < SUDOKU_SIZE; b++) {
            const boxUnit = [];
            const startRow = Math.floor(b / BOX_SIZE) * BOX_SIZE;
            const startCol = (b % BOX_SIZE) * BOX_SIZE;
            for (let i = 0; i < BOX_SIZE; i++) {
                for (let j = 0; j < BOX_SIZE; j++) {
                    const r = startRow + i;
                    const c = startCol + j;
                    boxUnit.push({ cell: grid[r][c], x: c, y: r });
                }
            }
            if (this.processUnit(boxUnit, isApply, strategyApplyCell)) return true;
        }
        return false;
    }
}

export const ns2 = new NakedSubsetsStrategy(2, "Naked Pairs", 2);
export const ns3 = new NakedSubsetsStrategy(3, "Naked Triples", 3);
export const ns4 = new NakedSubsetsStrategy(4, "Naked Quads", 4);