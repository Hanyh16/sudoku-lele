/**
 * @file Naked Pairs Strategy for Sudoku Solver
 * @author yyy
 * @description Implements the Naked Pairs strategy to eliminate candidates in Sudoku puzzles.
 * @date 2025-12-25
 */
import { BaseStrategy } from '@sudoku/strategy/baseStrategy';
import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';

/**
 * Naked Pairs Strategy
 * priority: 2
 * description: If two cells in a unit (row, column, or box) contain the same pair of candidates,
 *               those candidates can be eliminated from all other cells in that unit.
 */
class NakedPairsStrategy extends BaseStrategy {
    constructor(description = "Naked Pairs", priority = 2) {
        super();
        this.description = description;
        this.priority = priority;
    }

    /**
     * Check if two arrays of candidates are equal
     */
    areCandidatesEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) return false;
        return arr1.every(val => arr2.includes(val));
    }

    arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        const sortedA = [...a].sort();
        const sortedB = [...b].sort();
        return sortedA.every((val, index) => val === sortedB[index]);
    }

    preCondition(grid) {
        return this.scanGrid(grid, false);
    }


    /**
     * Apply the Naked Pairs strategy to the Sudoku grid.
     */
    apply(grid, strategyApplyCell) {
        return this.scanGrid(grid, true, strategyApplyCell);
    }

    strategyDescription() {
        return this.description;
    }

    /**
     * scan the entire grid for naked pairs
     * @param {boolean} isApply - if true, apply the changes to the grid
     * @param {Array} strategyApplyCell - array to record the cells that were changed
     */
    scanGrid(grid, isApply, strategyApplyCell = []) {

        // check rows
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            const rowUnit = grid[r].map((cell, c) => ({ cell, x: c, y: r }));
            if (this.processUnit(rowUnit, isApply, strategyApplyCell)) return true;
        }

        // check columns
        for (let c = 0; c < SUDOKU_SIZE; c++) {
            const colUnit = grid.map((row, r) => ({ cell: row[c], x: c, y: r }));
            if (this.processUnit(colUnit, isApply, strategyApplyCell)) return true;
        }

        // check boxes
        for (let b = 0; b < SUDOKU_SIZE; b++) {
            const boxUnit = [];
            const startRow = Math.floor(b / BOX_SIZE) * BOX_SIZE;
            const startCol = (b % BOX_SIZE) * BOX_SIZE;
            for (let i = 0; i < BOX_SIZE; i++) {
                for (let j = 0; j < BOX_SIZE; j++) {
                    const r = startRow + i;
                    const c = startCol + j;
                    boxUnit.push({ cell: grid[r][c], x: c, y: r });
                }
            }
            if (this.processUnit(boxUnit, isApply, strategyApplyCell)) return true;
        }
        return false;
    }

    /**
     * Process a single unit (row, column, or box) to find and apply naked pairs
     * @param {Array} unit - Array of objects containing {cell, x, y}
     */
    processUnit(unit, isApply, strategyApplyCell) {
        let changed = false;
        const candidatePairs = unit.filter(item => !item.cell.isCellConstant() && item.cell.candidates.length === 2);

        for (let i = 0; i < candidatePairs.length; i++) {
            for (let j = i + 1; j < candidatePairs.length; j++) {
                const itemA = candidatePairs[i];
                const itemB = candidatePairs[j];

                if (this.arraysEqual(itemA.cell.candidates, itemB.cell.candidates)) {
                    const numsToRemove = itemA.cell.candidates;

                    for (const targetItem of unit) {
                        const targetCell = targetItem.cell;

                        if (targetCell !== itemA.cell && targetCell !== itemB.cell && !targetCell.isCellConstant()) {
                            // Remove the naked pair candidates from other cells in the unit
                            if (targetCell.candidates.some(n => numsToRemove.includes(n))) {
                                if (!isApply) return true;

                                const beforeLen = targetCell.candidates.length;
                                targetCell.candidates = targetCell.candidates.filter(n => !numsToRemove.includes(n));

                                if (targetCell.candidates.length < beforeLen) {
                                    changed = true;
                                    targetCell.strategies.push(this);
                                    
                                    // record evidence positions
                                    const evidence = [{x: itemA.x, y: itemA.y}, {x: itemB.x, y: itemB.y}];
                                    evidence.forEach(ev => {
                                        if (!targetCell.relativePos.some(p => p.x === ev.x && p.y === ev.y)) {
                                            targetCell.relativePos.push(ev);
                                        }
                                    });

                                    if (!strategyApplyCell.some(pos => pos.x === targetItem.x && pos.y === targetItem.y)) {
                                        strategyApplyCell.push({ x: targetItem.x, y: targetItem.y });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if(changed){
            console.log("Naked Pairs applied");
            console.log(strategyApplyCell);
        }
        return changed;
    }
}

export const np = new NakedPairsStrategy();